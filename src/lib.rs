// Copyright 2017 Sreejith Krishnan R <sreejith@ganita.io>
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific language governing permissions
// and limitations under the License.

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen */

pub const FT_RENDER_POOL_SIZE: ::std::os::raw::c_uint = 16384;
pub const FT_MAX_MODULES: ::std::os::raw::c_uint = 32;
pub const TT_CONFIG_OPTION_SUBPIXEL_HINTING: ::std::os::raw::c_uint = 2;
pub const TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES: ::std::os::raw::c_uint =
    1000000;
pub const T1_MAX_DICT_DEPTH: ::std::os::raw::c_uint = 5;
pub const T1_MAX_SUBRS_CALLS: ::std::os::raw::c_uint = 16;
pub const T1_MAX_CHARSTRINGS_OPERANDS: ::std::os::raw::c_uint = 256;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1: ::std::os::raw::c_uint =
    500;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1: ::std::os::raw::c_uint =
    400;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2: ::std::os::raw::c_uint =
    1000;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2: ::std::os::raw::c_uint =
    275;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3: ::std::os::raw::c_uint =
    1667;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3: ::std::os::raw::c_uint =
    275;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4: ::std::os::raw::c_uint =
    2333;
pub const CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4: ::std::os::raw::c_uint =
    0;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __DARWIN_CLK_TCK: ::std::os::raw::c_uint = 100;
pub const CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 6;
pub const CLK_TCK: ::std::os::raw::c_uint = 100;
pub const SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const CHAR_MAX: ::std::os::raw::c_uint = 127;
pub const CHAR_MIN: ::std::os::raw::c_int = -128;
pub const USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const ULONG_MAX: ::std::os::raw::c_int = -1;
pub const LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const LONG_BIT: ::std::os::raw::c_uint = 64;
pub const SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const WORD_BIT: ::std::os::raw::c_uint = 32;
pub const SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 266;
pub const GID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const LINK_MAX: ::std::os::raw::c_uint = 32767;
pub const MAX_CANON: ::std::os::raw::c_uint = 1024;
pub const MAX_INPUT: ::std::os::raw::c_uint = 1024;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 16;
pub const UID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const OPEN_MAX: ::std::os::raw::c_uint = 10240;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const NZERO: ::std::os::raw::c_uint = 20;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 512;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 8192;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_SS_REPL_MAX: ::std::os::raw::c_uint = 4;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 30;
pub const _POSIX_TRACE_NAME_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_SYS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const PASS_MAX: ::std::os::raw::c_uint = 128;
pub const NL_ARGMAX: ::std::os::raw::c_uint = 9;
pub const NL_LANGMAX: ::std::os::raw::c_uint = 14;
pub const NL_MSGMAX: ::std::os::raw::c_uint = 32767;
pub const NL_NMAX: ::std::os::raw::c_uint = 1;
pub const NL_SETMAX: ::std::os::raw::c_uint = 255;
pub const NL_TEXTMAX: ::std::os::raw::c_uint = 2048;
pub const _XOPEN_IOV_MAX: ::std::os::raw::c_uint = 16;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const _XOPEN_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _XOPEN_PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const FT_CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const FT_USHORT_MAX: ::std::os::raw::c_uint = 65535;
pub const FT_INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const FT_INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const FT_UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const FT_LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const FT_LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const FT_ULONG_MAX: ::std::os::raw::c_int = -1;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __MAC_10_13: ::std::os::raw::c_uint = 101300;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __IPHONE_11_0: ::std::os::raw::c_uint = 110000;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __TVOS_11_0: ::std::os::raw::c_uint = 110000;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __WATCHOS_4_0: ::std::os::raw::c_uint = 40000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101300;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: ::std::os::raw::c_uint = 1;
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NSIG: ::std::os::raw::c_uint = 32;
pub const NSIG: ::std::os::raw::c_uint = 32;
pub const _I386_SIGNAL_H_: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGEMT: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGBUS: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGSYS: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGURG: ::std::os::raw::c_uint = 16;
pub const SIGSTOP: ::std::os::raw::c_uint = 17;
pub const SIGTSTP: ::std::os::raw::c_uint = 18;
pub const SIGCONT: ::std::os::raw::c_uint = 19;
pub const SIGCHLD: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGIO: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGINFO: ::std::os::raw::c_uint = 29;
pub const SIGUSR1: ::std::os::raw::c_uint = 30;
pub const SIGUSR2: ::std::os::raw::c_uint = 31;
pub const FP_PREC_24B: ::std::os::raw::c_uint = 0;
pub const FP_PREC_53B: ::std::os::raw::c_uint = 2;
pub const FP_PREC_64B: ::std::os::raw::c_uint = 3;
pub const FP_RND_NEAR: ::std::os::raw::c_uint = 0;
pub const FP_RND_DOWN: ::std::os::raw::c_uint = 1;
pub const FP_RND_UP: ::std::os::raw::c_uint = 2;
pub const FP_CHOP: ::std::os::raw::c_uint = 3;
pub const FP_STATE_BYTES: ::std::os::raw::c_uint = 512;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 3;
pub const ILL_NOOP: ::std::os::raw::c_uint = 0;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 2;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 3;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 4;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub const FPE_NOOP: ::std::os::raw::c_uint = 0;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 3;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 4;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 5;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 6;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 7;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 8;
pub const SEGV_NOOP: ::std::os::raw::c_uint = 0;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const BUS_NOOP: ::std::os::raw::c_uint = 0;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const TRAP_BRKPT: ::std::os::raw::c_uint = 1;
pub const TRAP_TRACE: ::std::os::raw::c_uint = 2;
pub const CLD_NOOP: ::std::os::raw::c_uint = 0;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SA_RESTART: ::std::os::raw::c_uint = 2;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SA_NODEFER: ::std::os::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 32;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 64;
pub const SA_USERTRAMP: ::std::os::raw::c_uint = 256;
pub const SA_64REGSET: ::std::os::raw::c_uint = 512;
pub const SA_USERSPACE_MASK: ::std::os::raw::c_uint = 127;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 2;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 3;
pub const SI_USER: ::std::os::raw::c_uint = 65537;
pub const SI_QUEUE: ::std::os::raw::c_uint = 65538;
pub const SI_TIMER: ::std::os::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::std::os::raw::c_uint = 65540;
pub const SI_MESGQ: ::std::os::raw::c_uint = 65541;
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 32768;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 131072;
pub const SV_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SV_INTERRUPT: ::std::os::raw::c_uint = 2;
pub const SV_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SV_NODEFER: ::std::os::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SV_SIGINFO: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const PRIO_DARWIN_THREAD: ::std::os::raw::c_uint = 3;
pub const PRIO_DARWIN_PROCESS: ::std::os::raw::c_uint = 4;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_DARWIN_BG: ::std::os::raw::c_uint = 4096;
pub const PRIO_DARWIN_NONUI: ::std::os::raw::c_uint = 4097;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_INFO_V0: ::std::os::raw::c_uint = 0;
pub const RUSAGE_INFO_V1: ::std::os::raw::c_uint = 1;
pub const RUSAGE_INFO_V2: ::std::os::raw::c_uint = 2;
pub const RUSAGE_INFO_V3: ::std::os::raw::c_uint = 3;
pub const RUSAGE_INFO_V4: ::std::os::raw::c_uint = 4;
pub const RUSAGE_INFO_CURRENT: ::std::os::raw::c_uint = 4;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 9;
pub const _RLIMIT_POSIX_FLAG: ::std::os::raw::c_uint = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: ::std::os::raw::c_uint = 2;
pub const RLIMIT_THREAD_CPULIMITS: ::std::os::raw::c_uint = 3;
pub const WAKEMON_ENABLE: ::std::os::raw::c_uint = 1;
pub const WAKEMON_DISABLE: ::std::os::raw::c_uint = 2;
pub const WAKEMON_GET_PARAMS: ::std::os::raw::c_uint = 4;
pub const WAKEMON_SET_DEFAULTS: ::std::os::raw::c_uint = 8;
pub const WAKEMON_MAKE_FATAL: ::std::os::raw::c_uint = 16;
pub const CPUMON_MAKE_FATAL: ::std::os::raw::c_uint = 4096;
pub const IOPOL_TYPE_DISK: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_PROCESS: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_THREAD: ::std::os::raw::c_uint = 1;
pub const IOPOL_SCOPE_DARWIN_BG: ::std::os::raw::c_uint = 2;
pub const IOPOL_DEFAULT: ::std::os::raw::c_uint = 0;
pub const IOPOL_IMPORTANT: ::std::os::raw::c_uint = 1;
pub const IOPOL_PASSIVE: ::std::os::raw::c_uint = 2;
pub const IOPOL_THROTTLE: ::std::os::raw::c_uint = 3;
pub const IOPOL_UTILITY: ::std::os::raw::c_uint = 4;
pub const IOPOL_STANDARD: ::std::os::raw::c_uint = 5;
pub const IOPOL_APPLICATION: ::std::os::raw::c_uint = 5;
pub const IOPOL_NORMAL: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _WSTOPPED: ::std::os::raw::c_uint = 127;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WSTOPPED: ::std::os::raw::c_uint = 8;
pub const WCONTINUED: ::std::os::raw::c_uint = 16;
pub const WNOWAIT: ::std::os::raw::c_uint = 32;
pub const WAIT_ANY: ::std::os::raw::c_int = -1;
pub const WAIT_MYPGRP: ::std::os::raw::c_uint = 0;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const __DARWIN_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __DARWIN_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __DARWIN_BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _JBLEN: ::std::os::raw::c_uint = 37;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const HAVE_UNISTD_H: ::std::os::raw::c_uint = 1;
pub const HAVE_FCNTL_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STDINT_H: ::std::os::raw::c_uint = 1;
pub const FT_SIZEOF_INT: ::std::os::raw::c_uint = 4;
pub const FT_SIZEOF_LONG: ::std::os::raw::c_uint = 8;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EDEADLK: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EAGAIN: ::std::os::raw::c_uint = 35;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 35;
pub const EINPROGRESS: ::std::os::raw::c_uint = 36;
pub const EALREADY: ::std::os::raw::c_uint = 37;
pub const ENOTSOCK: ::std::os::raw::c_uint = 38;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 39;
pub const EMSGSIZE: ::std::os::raw::c_uint = 40;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 41;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 44;
pub const ENOTSUP: ::std::os::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 47;
pub const EADDRINUSE: ::std::os::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 49;
pub const ENETDOWN: ::std::os::raw::c_uint = 50;
pub const ENETUNREACH: ::std::os::raw::c_uint = 51;
pub const ENETRESET: ::std::os::raw::c_uint = 52;
pub const ECONNABORTED: ::std::os::raw::c_uint = 53;
pub const ECONNRESET: ::std::os::raw::c_uint = 54;
pub const ENOBUFS: ::std::os::raw::c_uint = 55;
pub const EISCONN: ::std::os::raw::c_uint = 56;
pub const ENOTCONN: ::std::os::raw::c_uint = 57;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 58;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 59;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 60;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 61;
pub const ELOOP: ::std::os::raw::c_uint = 62;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 63;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 64;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 65;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 66;
pub const EPROCLIM: ::std::os::raw::c_uint = 67;
pub const EUSERS: ::std::os::raw::c_uint = 68;
pub const EDQUOT: ::std::os::raw::c_uint = 69;
pub const ESTALE: ::std::os::raw::c_uint = 70;
pub const EREMOTE: ::std::os::raw::c_uint = 71;
pub const EBADRPC: ::std::os::raw::c_uint = 72;
pub const ERPCMISMATCH: ::std::os::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::std::os::raw::c_uint = 74;
pub const EPROGMISMATCH: ::std::os::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::std::os::raw::c_uint = 76;
pub const ENOLCK: ::std::os::raw::c_uint = 77;
pub const ENOSYS: ::std::os::raw::c_uint = 78;
pub const EFTYPE: ::std::os::raw::c_uint = 79;
pub const EAUTH: ::std::os::raw::c_uint = 80;
pub const ENEEDAUTH: ::std::os::raw::c_uint = 81;
pub const EPWROFF: ::std::os::raw::c_uint = 82;
pub const EDEVERR: ::std::os::raw::c_uint = 83;
pub const EOVERFLOW: ::std::os::raw::c_uint = 84;
pub const EBADEXEC: ::std::os::raw::c_uint = 85;
pub const EBADARCH: ::std::os::raw::c_uint = 86;
pub const ESHLIBVERS: ::std::os::raw::c_uint = 87;
pub const EBADMACHO: ::std::os::raw::c_uint = 88;
pub const ECANCELED: ::std::os::raw::c_uint = 89;
pub const EIDRM: ::std::os::raw::c_uint = 90;
pub const ENOMSG: ::std::os::raw::c_uint = 91;
pub const EILSEQ: ::std::os::raw::c_uint = 92;
pub const ENOATTR: ::std::os::raw::c_uint = 93;
pub const EBADMSG: ::std::os::raw::c_uint = 94;
pub const EMULTIHOP: ::std::os::raw::c_uint = 95;
pub const ENODATA: ::std::os::raw::c_uint = 96;
pub const ENOLINK: ::std::os::raw::c_uint = 97;
pub const ENOSR: ::std::os::raw::c_uint = 98;
pub const ENOSTR: ::std::os::raw::c_uint = 99;
pub const EPROTO: ::std::os::raw::c_uint = 100;
pub const ETIME: ::std::os::raw::c_uint = 101;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 102;
pub const ENOPOLICY: ::std::os::raw::c_uint = 103;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 104;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 105;
pub const EQFULL: ::std::os::raw::c_uint = 106;
pub const ELAST: ::std::os::raw::c_uint = 106;
pub const MAC_OS_X_VERSION_10_0: ::std::os::raw::c_uint = 1000;
pub const MAC_OS_X_VERSION_10_1: ::std::os::raw::c_uint = 1010;
pub const MAC_OS_X_VERSION_10_2: ::std::os::raw::c_uint = 1020;
pub const MAC_OS_X_VERSION_10_3: ::std::os::raw::c_uint = 1030;
pub const MAC_OS_X_VERSION_10_4: ::std::os::raw::c_uint = 1040;
pub const MAC_OS_X_VERSION_10_5: ::std::os::raw::c_uint = 1050;
pub const MAC_OS_X_VERSION_10_6: ::std::os::raw::c_uint = 1060;
pub const MAC_OS_X_VERSION_10_7: ::std::os::raw::c_uint = 1070;
pub const MAC_OS_X_VERSION_10_8: ::std::os::raw::c_uint = 1080;
pub const MAC_OS_X_VERSION_10_9: ::std::os::raw::c_uint = 1090;
pub const MAC_OS_X_VERSION_10_10: ::std::os::raw::c_uint = 101000;
pub const MAC_OS_X_VERSION_10_10_2: ::std::os::raw::c_uint = 101002;
pub const MAC_OS_X_VERSION_10_10_3: ::std::os::raw::c_uint = 101003;
pub const MAC_OS_X_VERSION_10_11: ::std::os::raw::c_uint = 101100;
pub const MAC_OS_X_VERSION_10_11_2: ::std::os::raw::c_uint = 101102;
pub const MAC_OS_X_VERSION_10_11_3: ::std::os::raw::c_uint = 101103;
pub const MAC_OS_X_VERSION_10_11_4: ::std::os::raw::c_uint = 101104;
pub const MAC_OS_X_VERSION_10_12: ::std::os::raw::c_uint = 101200;
pub const MAC_OS_X_VERSION_10_12_1: ::std::os::raw::c_uint = 101201;
pub const MAC_OS_X_VERSION_10_12_2: ::std::os::raw::c_uint = 101202;
pub const MAC_OS_X_VERSION_10_12_4: ::std::os::raw::c_uint = 101204;
pub const MAC_OS_X_VERSION_10_13: ::std::os::raw::c_uint = 101300;
pub const MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101300;
pub const __AVAILABILITY_MACROS_USES_AVAILABILITY: ::std::os::raw::c_uint = 1;
pub const FT_OUTLINE_CONTOURS_MAX: ::std::os::raw::c_uint = 32767;
pub const FT_OUTLINE_POINTS_MAX: ::std::os::raw::c_uint = 32767;
pub const FT_OUTLINE_NONE: ::std::os::raw::c_uint = 0;
pub const FT_OUTLINE_OWNER: ::std::os::raw::c_uint = 1;
pub const FT_OUTLINE_EVEN_ODD_FILL: ::std::os::raw::c_uint = 2;
pub const FT_OUTLINE_REVERSE_FILL: ::std::os::raw::c_uint = 4;
pub const FT_OUTLINE_IGNORE_DROPOUTS: ::std::os::raw::c_uint = 8;
pub const FT_OUTLINE_SMART_DROPOUTS: ::std::os::raw::c_uint = 16;
pub const FT_OUTLINE_INCLUDE_STUBS: ::std::os::raw::c_uint = 32;
pub const FT_OUTLINE_HIGH_PRECISION: ::std::os::raw::c_uint = 256;
pub const FT_OUTLINE_SINGLE_PASS: ::std::os::raw::c_uint = 512;
pub const ft_outline_none: ::std::os::raw::c_uint = 0;
pub const ft_outline_owner: ::std::os::raw::c_uint = 1;
pub const ft_outline_even_odd_fill: ::std::os::raw::c_uint = 2;
pub const ft_outline_reverse_fill: ::std::os::raw::c_uint = 4;
pub const ft_outline_ignore_dropouts: ::std::os::raw::c_uint = 8;
pub const ft_outline_high_precision: ::std::os::raw::c_uint = 256;
pub const ft_outline_single_pass: ::std::os::raw::c_uint = 512;
pub const FT_CURVE_TAG_ON: ::std::os::raw::c_uint = 1;
pub const FT_CURVE_TAG_CONIC: ::std::os::raw::c_uint = 0;
pub const FT_CURVE_TAG_CUBIC: ::std::os::raw::c_uint = 2;
pub const FT_CURVE_TAG_HAS_SCANMODE: ::std::os::raw::c_uint = 4;
pub const FT_CURVE_TAG_TOUCH_X: ::std::os::raw::c_uint = 8;
pub const FT_CURVE_TAG_TOUCH_Y: ::std::os::raw::c_uint = 16;
pub const FT_CURVE_TAG_TOUCH_BOTH: ::std::os::raw::c_uint = 24;
pub const FT_Curve_Tag_On: ::std::os::raw::c_uint = 1;
pub const FT_Curve_Tag_Conic: ::std::os::raw::c_uint = 0;
pub const FT_Curve_Tag_Cubic: ::std::os::raw::c_uint = 2;
pub const FT_Curve_Tag_Touch_X: ::std::os::raw::c_uint = 8;
pub const FT_Curve_Tag_Touch_Y: ::std::os::raw::c_uint = 16;
pub const FT_RASTER_FLAG_DEFAULT: ::std::os::raw::c_uint = 0;
pub const FT_RASTER_FLAG_AA: ::std::os::raw::c_uint = 1;
pub const FT_RASTER_FLAG_DIRECT: ::std::os::raw::c_uint = 2;
pub const FT_RASTER_FLAG_CLIP: ::std::os::raw::c_uint = 4;
pub const ft_raster_flag_default: ::std::os::raw::c_uint = 0;
pub const ft_raster_flag_aa: ::std::os::raw::c_uint = 1;
pub const ft_raster_flag_direct: ::std::os::raw::c_uint = 2;
pub const ft_raster_flag_clip: ::std::os::raw::c_uint = 4;
pub const FT_ERR_BASE: ::std::os::raw::c_uint = 0;
pub const FT_FACE_FLAG_SCALABLE: ::std::os::raw::c_uint = 1;
pub const FT_FACE_FLAG_FIXED_SIZES: ::std::os::raw::c_uint = 2;
pub const FT_FACE_FLAG_FIXED_WIDTH: ::std::os::raw::c_uint = 4;
pub const FT_FACE_FLAG_SFNT: ::std::os::raw::c_uint = 8;
pub const FT_FACE_FLAG_HORIZONTAL: ::std::os::raw::c_uint = 16;
pub const FT_FACE_FLAG_VERTICAL: ::std::os::raw::c_uint = 32;
pub const FT_FACE_FLAG_KERNING: ::std::os::raw::c_uint = 64;
pub const FT_FACE_FLAG_FAST_GLYPHS: ::std::os::raw::c_uint = 128;
pub const FT_FACE_FLAG_MULTIPLE_MASTERS: ::std::os::raw::c_uint = 256;
pub const FT_FACE_FLAG_GLYPH_NAMES: ::std::os::raw::c_uint = 512;
pub const FT_FACE_FLAG_EXTERNAL_STREAM: ::std::os::raw::c_uint = 1024;
pub const FT_FACE_FLAG_HINTER: ::std::os::raw::c_uint = 2048;
pub const FT_FACE_FLAG_CID_KEYED: ::std::os::raw::c_uint = 4096;
pub const FT_FACE_FLAG_TRICKY: ::std::os::raw::c_uint = 8192;
pub const FT_FACE_FLAG_COLOR: ::std::os::raw::c_uint = 16384;
pub const FT_STYLE_FLAG_ITALIC: ::std::os::raw::c_uint = 1;
pub const FT_STYLE_FLAG_BOLD: ::std::os::raw::c_uint = 2;
pub const FT_OPEN_MEMORY: ::std::os::raw::c_uint = 1;
pub const FT_OPEN_STREAM: ::std::os::raw::c_uint = 2;
pub const FT_OPEN_PATHNAME: ::std::os::raw::c_uint = 4;
pub const FT_OPEN_DRIVER: ::std::os::raw::c_uint = 8;
pub const FT_OPEN_PARAMS: ::std::os::raw::c_uint = 16;
pub const ft_open_memory: ::std::os::raw::c_uint = 1;
pub const ft_open_stream: ::std::os::raw::c_uint = 2;
pub const ft_open_pathname: ::std::os::raw::c_uint = 4;
pub const ft_open_driver: ::std::os::raw::c_uint = 8;
pub const ft_open_params: ::std::os::raw::c_uint = 16;
pub const FT_LOAD_DEFAULT: ::std::os::raw::c_uint = 0;
pub const FT_LOAD_NO_SCALE: ::std::os::raw::c_uint = 1;
pub const FT_LOAD_NO_HINTING: ::std::os::raw::c_uint = 2;
pub const FT_LOAD_RENDER: ::std::os::raw::c_uint = 4;
pub const FT_LOAD_NO_BITMAP: ::std::os::raw::c_uint = 8;
pub const FT_LOAD_VERTICAL_LAYOUT: ::std::os::raw::c_uint = 16;
pub const FT_LOAD_FORCE_AUTOHINT: ::std::os::raw::c_uint = 32;
pub const FT_LOAD_CROP_BITMAP: ::std::os::raw::c_uint = 64;
pub const FT_LOAD_PEDANTIC: ::std::os::raw::c_uint = 128;
pub const FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH: ::std::os::raw::c_uint = 512;
pub const FT_LOAD_NO_RECURSE: ::std::os::raw::c_uint = 1024;
pub const FT_LOAD_IGNORE_TRANSFORM: ::std::os::raw::c_uint = 2048;
pub const FT_LOAD_MONOCHROME: ::std::os::raw::c_uint = 4096;
pub const FT_LOAD_LINEAR_DESIGN: ::std::os::raw::c_uint = 8192;
pub const FT_LOAD_NO_AUTOHINT: ::std::os::raw::c_uint = 32768;
pub const FT_LOAD_COLOR: ::std::os::raw::c_uint = 1048576;
pub const FT_LOAD_COMPUTE_METRICS: ::std::os::raw::c_uint = 2097152;
pub const FT_LOAD_BITMAP_METRICS_ONLY: ::std::os::raw::c_uint = 4194304;
pub const FT_LOAD_ADVANCE_ONLY: ::std::os::raw::c_uint = 256;
pub const FT_LOAD_SBITS_ONLY: ::std::os::raw::c_uint = 16384;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS: ::std::os::raw::c_uint = 1;
pub const FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES: ::std::os::raw::c_uint = 2;
pub const FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID: ::std::os::raw::c_uint = 4;
pub const FT_SUBGLYPH_FLAG_SCALE: ::std::os::raw::c_uint = 8;
pub const FT_SUBGLYPH_FLAG_XY_SCALE: ::std::os::raw::c_uint = 64;
pub const FT_SUBGLYPH_FLAG_2X2: ::std::os::raw::c_uint = 128;
pub const FT_SUBGLYPH_FLAG_USE_MY_METRICS: ::std::os::raw::c_uint = 512;
pub const FT_FSTYPE_INSTALLABLE_EMBEDDING: ::std::os::raw::c_uint = 0;
pub const FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING: ::std::os::raw::c_uint = 2;
pub const FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING: ::std::os::raw::c_uint = 4;
pub const FT_FSTYPE_EDITABLE_EMBEDDING: ::std::os::raw::c_uint = 8;
pub const FT_FSTYPE_NO_SUBSETTING: ::std::os::raw::c_uint = 256;
pub const FT_FSTYPE_BITMAP_EMBEDDING_ONLY: ::std::os::raw::c_uint = 512;
pub const FREETYPE_MAJOR: ::std::os::raw::c_uint = 2;
pub const FREETYPE_MINOR: ::std::os::raw::c_uint = 8;
pub const FREETYPE_PATCH: ::std::os::raw::c_uint = 1;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dst: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dst: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__b: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(__s1: *mut ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(__dst: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __charset: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(__s1: *mut ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(__dst: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __charset: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __charset: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(__big: *const ::std::os::raw::c_char,
                  __little: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__str: *mut ::std::os::raw::c_char,
                  __sep: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(__s1: *mut ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(__str: *mut ::std::os::raw::c_char,
                    __sep: *const ::std::os::raw::c_char,
                    __lasts: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __strerrbuf: *mut ::std::os::raw::c_char,
                      __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(__dst: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(__dst: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dst: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(__s: *mut ::std::os::raw::c_void, __smax: rsize_t,
                    __c: ::std::os::raw::c_int, __n: rsize_t) -> errno_t;
}
extern "C" {
    pub fn memmem(__big: *const ::std::os::raw::c_void, __big_len: usize,
                  __little: *const ::std::os::raw::c_void,
                  __little_len: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(__b: *mut ::std::os::raw::c_void,
                           __pattern4: *const ::std::os::raw::c_void,
                           __len: usize);
}
extern "C" {
    pub fn memset_pattern8(__b: *mut ::std::os::raw::c_void,
                           __pattern8: *const ::std::os::raw::c_void,
                           __len: usize);
}
extern "C" {
    pub fn memset_pattern16(__b: *mut ::std::os::raw::c_void,
                            __pattern16: *const ::std::os::raw::c_void,
                            __len: usize);
}
extern "C" {
    pub fn strcasestr(__big: *const ::std::os::raw::c_char,
                      __little: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(__big: *const ::std::os::raw::c_char,
                   __little: *const ::std::os::raw::c_char, __len: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(__dst: *mut ::std::os::raw::c_char,
                   __source: *const ::std::os::raw::c_char, __size: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(__dst: *mut ::std::os::raw::c_char,
                   __source: *const ::std::os::raw::c_char, __size: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int,
                   __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(arg1: *const ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void, arg3: isize);
}
extern "C" {
    pub fn timingsafe_bcmp(__b1: *const ::std::os::raw::c_void,
                           __b2: *const ::std::os::raw::c_void, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::std::os::raw::c_void,
                 arg2: *mut ::std::os::raw::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn index(arg1: *const ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(arg1: ::std::os::raw::c_int,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __prefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                     __format: *const ::std::os::raw::c_char,
                     arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__str: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(__linep: *mut *mut ::std::os::raw::c_char,
                    __linecapp: *mut usize,
                    __delimiter: ::std::os::raw::c_int, __stream: *mut FILE)
     -> isize;
}
extern "C" {
    pub fn getline(__linep: *mut *mut ::std::os::raw::c_char,
                   __linecapp: *mut usize, __stream: *mut FILE) -> isize;
}
extern "C" {
    pub fn fmemopen(__buf: *mut ::std::os::raw::c_void, __size: usize,
                    __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufp: *mut *mut ::std::os::raw::c_char,
                          __sizep: *mut usize) -> *mut FILE;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_thread_state>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_thread_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_thread_state>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_thread_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eax as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebx as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ecx as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ecx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edx as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edi as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esi as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esp as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ss as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eflags
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eflags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eip as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __cs as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ds as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __es as
                * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __fs as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __gs as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __gs ) ));
}
impl Clone for __darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_control {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_control>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( __darwin_fp_control ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_control>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_fp_control ) ));
}
impl Clone for __darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 768u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 3072u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 3072u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __pc: ::std::os::raw::c_ushort,
                          __rc: ::std::os::raw::c_ushort) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((__invalid as u16 as u16) <<
                                                     0usize) & (1u64 as u16))
                                       } |
                                           ((__denorm as u16 as u16) <<
                                                1usize) & (2u64 as u16))
                                  } |
                                      ((__zdiv as u16 as u16) << 2usize) &
                                          (4u64 as u16))
                             } |
                                 ((__ovrfl as u16 as u16) << 3usize) &
                                     (8u64 as u16))
                        } |
                            ((__undfl as u16 as u16) << 4usize) &
                                (16u64 as u16))
                   } | ((__precis as u16 as u16) << 5usize) & (32u64 as u16))
              } | ((__pc as u16 as u16) << 8usize) & (768u64 as u16))
         } | ((__rc as u16 as u16) << 10usize) & (3072u64 as u16))
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_status {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_status>() , 2usize , concat !
               ( "Size of: " , stringify ! ( __darwin_fp_status ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_status>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_fp_status ) ));
}
impl Clone for __darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 256u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 512u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1024u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 14336u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 14336u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16384u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __stkflt: ::std::os::raw::c_ushort,
                          __errsumm: ::std::os::raw::c_ushort,
                          __c0: ::std::os::raw::c_ushort,
                          __c1: ::std::os::raw::c_ushort,
                          __c2: ::std::os::raw::c_ushort,
                          __tos: ::std::os::raw::c_ushort,
                          __c3: ::std::os::raw::c_ushort,
                          __busy: ::std::os::raw::c_ushort) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              0
                                                                          } |
                                                                              ((__invalid
                                                                                    as
                                                                                    u16
                                                                                    as
                                                                                    u16)
                                                                                   <<
                                                                                   0usize)
                                                                                  &
                                                                                  (1u64
                                                                                       as
                                                                                       u16))
                                                                     } |
                                                                         ((__denorm
                                                                               as
                                                                               u16
                                                                               as
                                                                               u16)
                                                                              <<
                                                                              1usize)
                                                                             &
                                                                             (2u64
                                                                                  as
                                                                                  u16))
                                                                } |
                                                                    ((__zdiv
                                                                          as
                                                                          u16
                                                                          as
                                                                          u16)
                                                                         <<
                                                                         2usize)
                                                                        &
                                                                        (4u64
                                                                             as
                                                                             u16))
                                                           } |
                                                               ((__ovrfl as
                                                                     u16 as
                                                                     u16) <<
                                                                    3usize) &
                                                                   (8u64 as
                                                                        u16))
                                                      } |
                                                          ((__undfl as u16 as
                                                                u16) <<
                                                               4usize) &
                                                              (16u64 as u16))
                                                 } |
                                                     ((__precis as u16 as u16)
                                                          << 5usize) &
                                                         (32u64 as u16))
                                            } |
                                                ((__stkflt as u16 as u16) <<
                                                     6usize) & (64u64 as u16))
                                       } |
                                           ((__errsumm as u16 as u16) <<
                                                7usize) & (128u64 as u16))
                                  } |
                                      ((__c0 as u16 as u16) << 8usize) &
                                          (256u64 as u16))
                             } |
                                 ((__c1 as u16 as u16) << 9usize) &
                                     (512u64 as u16))
                        } |
                            ((__c2 as u16 as u16) << 10usize) &
                                (1024u64 as u16))
                   } | ((__tos as u16 as u16) << 11usize) & (14336u64 as u16))
              } | ((__c3 as u16 as u16) << 14usize) & (16384u64 as u16))
         } | ((__busy as u16 as u16) << 15usize) & (32768u64 as u16))
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_mmst_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mmst_reg>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_rsrv as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_rsrv ) ));
}
impl Clone for __darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_xmm_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_xmm_reg>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_xmm_reg ) ) . __xmm_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_xmm_reg ) ,
                "::" , stringify ! ( __xmm_reg ) ));
}
impl Clone for __darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_ymm_reg>() , 32usize , concat !
               ( "Size of: " , stringify ! ( __darwin_ymm_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_ymm_reg>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( __darwin_ymm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ymm_reg ) ) . __ymm_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ymm_reg ) ,
                "::" , stringify ! ( __ymm_reg ) ));
}
impl Clone for __darwin_ymm_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_zmm_reg>() , 64usize , concat !
               ( "Size of: " , stringify ! ( __darwin_zmm_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_zmm_reg>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( __darwin_zmm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_zmm_reg ) ) . __zmm_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_zmm_reg ) ,
                "::" , stringify ! ( __zmm_reg ) ));
}
impl Clone for __darwin_zmm_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_opmask_reg>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( __darwin_opmask_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_opmask_reg>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_opmask_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_opmask_reg ) ) . __opmask_reg as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_opmask_reg ) ,
                "::" , stringify ! ( __opmask_reg ) ));
}
impl Clone for __darwin_opmask_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_float_state>() , 524usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_float_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_float_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_float_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
impl Clone for __darwin_i386_float_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx_state>() , 716usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_avx_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fcw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv1
                as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ip as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_cs as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv2
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_dp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_dp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ds as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv3
                as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_mxcsr
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm0
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm1
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm2
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm3
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm4
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm5
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm6
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm7
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv4
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh0
                as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh1
                as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh2
                as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh3
                as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh4
                as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh5
                as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh6
                as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh7
                as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh7 ) ));
}
impl Clone for __darwin_i386_avx_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx512_state>() , 1036usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_i386_avx512_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_avx512_state>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_avx512_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_fcw as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_fcw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_fsw as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_fsw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ftw as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ftw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_fop as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_fop
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_ymmh7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k0
                as * const _ as usize } , 716usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k1
                as * const _ as usize } , 724usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k2
                as * const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k3
                as * const _ as usize } , 740usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k4
                as * const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k5
                as * const _ as usize } , 756usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k6
                as * const _ as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k7
                as * const _ as usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k7 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh0 as * const _ as usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh1 as * const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh2 as * const _ as usize } , 844usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh3 as * const _ as usize } , 876usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh4 as * const _ as usize } , 908usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh5 as * const _ as usize } , 940usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh6 as * const _ as usize } , 972usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx512_state ) ) .
                __fpu_zmmh7 as * const _ as usize } , 1004usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_avx512_state ) , "::" , stringify ! (
                __fpu_zmmh7 ) ));
}
impl Clone for __darwin_i386_avx512_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_exception_state>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( __darwin_i386_exception_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_exception_state>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_exception_state
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __cpu
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __cpu )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __err
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __err )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state32>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state32>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state32 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr1 as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr2 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr3 as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr4 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr5 as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr6 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr7 as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_thread_state64>() , 168usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_thread_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_thread_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_thread_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rax
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbx
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rcx
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rcx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdx
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdi
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsi
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbp
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsp
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r8 as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r9 as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r10
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r10 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r11
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r11 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r12
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r12 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r13
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r13 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r14
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r14 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r15
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r15 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rip
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) .
                __rflags as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rflags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __cs as
                * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __fs as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __fs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __gs as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __gs )
                ));
}
impl Clone for __darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_float_state64>() , 524usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_float_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_float_state64>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_float_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fcw as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fcw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fsw as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fsw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_ftw as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ftw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fop as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fop
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm8 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm9 as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
impl Clone for __darwin_x86_float_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx_state64>() , 844usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_avx_state64>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm7 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm8
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm9
                as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm15
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh8 as * const _ as usize } , 716usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh9 as * const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh10 as * const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh11 as * const _ as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh12 as * const _ as usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh13 as * const _ as usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh14 as * const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh15 as * const _ as usize } , 828usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh15
                ) ));
}
impl Clone for __darwin_x86_avx_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx512_state64>() ,
               2444usize , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_avx512_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_avx512_state64>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_avx512_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_fcw as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_fcw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_fsw as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_fsw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ftw as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ftw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_fop as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_fop
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ip as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ip
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_cs as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_cs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_dp as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_dp
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ds as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ds
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm8 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm9 as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_xmm15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh8 as * const _ as usize } , 716usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh9 as * const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh10 as * const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh11 as * const _ as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh12 as * const _ as usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh13 as * const _ as usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh14 as * const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_ymmh15 as * const _ as usize } , 828usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_ymmh15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k0 as * const _ as usize } , 844usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k1 as * const _ as usize } , 852usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k2 as * const _ as usize } , 860usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k3 as * const _ as usize } , 868usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k4 as * const _ as usize } , 876usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k5 as * const _ as usize } , 884usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k6 as * const _ as usize } , 892usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_k7 as * const _ as usize } , 900usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh0 as * const _ as usize } , 908usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh1 as * const _ as usize } , 940usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh2 as * const _ as usize } , 972usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh3 as * const _ as usize } , 1004usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh4 as * const _ as usize } , 1036usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh5 as * const _ as usize } , 1068usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh6 as * const _ as usize } , 1100usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh7 as * const _ as usize } , 1132usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh8 as * const _ as usize } , 1164usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh9 as * const _ as usize } , 1196usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh10 as * const _ as usize } , 1228usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh11 as * const _ as usize } , 1260usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh12 as * const _ as usize } , 1292usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh13 as * const _ as usize } , 1324usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh14 as * const _ as usize } , 1356usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmmh15 as * const _ as usize } , 1388usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmmh15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm16 as * const _ as usize } , 1420usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm17 as * const _ as usize } , 1484usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm18 as * const _ as usize } , 1548usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm18 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm19 as * const _ as usize } , 1612usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm20 as * const _ as usize } , 1676usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm20 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm21 as * const _ as usize } , 1740usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm21 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm22 as * const _ as usize } , 1804usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm22 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm23 as * const _ as usize } , 1868usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm23 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm24 as * const _ as usize } , 1932usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm24 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm25 as * const _ as usize } , 1996usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm25 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm26 as * const _ as usize } , 2060usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm26 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm27 as * const _ as usize } , 2124usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm27 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm28 as * const _ as usize } , 2188usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm28 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm29 as * const _ as usize } , 2252usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm29 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm30 as * const _ as usize } , 2316usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm30 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) .
                __fpu_zmm31 as * const _ as usize } , 2380usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx512_state64 ) , "::" , stringify ! (
                __fpu_zmm31 ) ));
}
impl Clone for __darwin_x86_avx512_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_exception_state64>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_exception_state64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_exception_state64>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_exception_state64
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __cpu as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __cpu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __err as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __err
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state64>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr1 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr2 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr3 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr4 as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr5 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr6 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr7 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_cpmu_state64>() , 128usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_cpmu_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_cpmu_state64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_cpmu_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_cpmu_state64 ) ) . __ctrs as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_cpmu_state64 ) , "::" , stringify ! ( __ctrs )
                ));
}
impl Clone for __darwin_x86_cpmu_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext32>() , 600usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext32 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __ss as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __fs as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx32>() , 792usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __ss as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __fs as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext_avx32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx512_32>() ,
               1112usize , concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx512_32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx512_32>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx512_32 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx512_32 ) ) . __es as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_mcontext_avx512_32 ) , "::" , stringify ! ( __es )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx512_32 ) ) . __ss as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_mcontext_avx512_32 ) , "::" , stringify ! ( __ss )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx512_32 ) ) . __fs as
                * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_mcontext_avx512_32 ) , "::" , stringify ! ( __fs )
                ));
}
impl Clone for __darwin_mcontext_avx512_32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext64>() , 712usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __ss as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __fs as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx64>() , 1032usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __ss as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __fs as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __fs ) ));
}
impl Clone for __darwin_mcontext_avx64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx512_64>() ,
               2632usize , concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx512_64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx512_64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx512_64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx512_64 ) ) . __es as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_mcontext_avx512_64 ) , "::" , stringify ! ( __es )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx512_64 ) ) . __ss as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_mcontext_avx512_64 ) , "::" , stringify ! ( __ss )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx512_64 ) ) . __fs as
                * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_mcontext_avx512_64 ) , "::" , stringify ! ( __fs )
                ));
}
impl Clone for __darwin_mcontext_avx512_64 {
    fn clone(&self) -> Self { *self }
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(::std::mem::size_of::<__darwin_sigaltstack>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_sigaltstack )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_sigaltstack>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_sp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_flags ) ));
}
impl Clone for __darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(::std::mem::size_of::<__darwin_ucontext>() , 56usize , concat !
               ( "Size of: " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (::std::mem::align_of::<__darwin_ucontext>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_onstack as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_sigmask as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_stack as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_link as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcontext as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcontext ) ));
}
impl Clone for __darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::std::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::std::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_function as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_attributes as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_attributes ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(::std::mem::size_of::<__siginfo>() , 104usize , concat ! (
               "Size of: " , stringify ! ( __siginfo ) ));
    assert_eq! (::std::mem::align_of::<__siginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_value as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_band as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . __pad as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for __siginfo {
    fn clone(&self) -> Self { *self }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       ::std::os::raw::c_int,
                                                                   arg2:
                                                                       *mut __siginfo,
                                                                   arg3:
                                                                       *mut ::std::os::raw::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(::std::mem::size_of::<__sigaction_u>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __sigaction_u ) ));
    assert_eq! (::std::mem::align_of::<__sigaction_u>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_sigaction as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_sigaction ) ));
}
impl Clone for __sigaction_u {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 ::std::os::raw::c_int,
                                                             arg4:
                                                                 *mut siginfo_t,
                                                             arg5:
                                                                 *mut ::std::os::raw::c_void)>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(::std::mem::size_of::<__sigaction>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __sigaction ) ));
    assert_eq! (::std::mem::align_of::<__sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . __sigaction_u as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_tramp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_tramp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_mask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_flags as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for __sigaction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::std::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_u as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
pub type sig_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(::std::mem::size_of::<sigvec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigvec ) ));
    assert_eq! (::std::mem::align_of::<sigvec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_handler as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_flags ) ));
}
impl Clone for sigvec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::std::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn signal(arg1: ::std::os::raw::c_int,
                  arg2:
                      ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                        ::std::os::raw::c_int,
                                                    arg2:
                                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                       ::std::os::raw::c_int)>)>;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::std::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::std::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(::std::mem::size_of::<rusage_info_v0>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
}
impl Clone for rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(::std::mem::size_of::<rusage_info_v1>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
}
impl Clone for rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(::std::mem::size_of::<rusage_info_v2>() , 160usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
}
impl Clone for rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(::std::mem::size_of::<rusage_info_v3>() , 232usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_default as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_maintenance as * const _ as usize } , 168usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_maintenance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_background as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_utility as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_utility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_legacy as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_legacy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_initiated as * const _ as usize } ,
                200usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_initiated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_interactive as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_interactive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_billed_system_time as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_billed_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_serviced_system_time as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_serviced_system_time ) ));
}
impl Clone for rusage_info_v3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_unused: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(::std::mem::size_of::<rusage_info_v4>() , 296usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v4 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v4>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_cpu_time_qos_default as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cpu_time_qos_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_cpu_time_qos_maintenance as * const _ as usize } , 168usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cpu_time_qos_maintenance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_cpu_time_qos_background as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cpu_time_qos_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_cpu_time_qos_utility as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cpu_time_qos_utility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_cpu_time_qos_legacy as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cpu_time_qos_legacy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_cpu_time_qos_user_initiated as * const _ as usize } ,
                200usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_initiated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_cpu_time_qos_user_interactive as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_interactive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_billed_system_time as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_billed_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_serviced_system_time as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_serviced_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_logical_writes as
                * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_logical_writes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) .
                ri_lifetime_max_phys_footprint as * const _ as usize } ,
                240usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_lifetime_max_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_instructions as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_instructions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cycles as * const
                _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_cycles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_billed_energy as
                * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_billed_energy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_serviced_energy
                as * const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_serviced_energy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v4 ) ) . ri_unused as * const
                _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::"
                , stringify ! ( ri_unused ) ));
}
impl Clone for rusage_info_v4 {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::std::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::std::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(::std::mem::size_of::<proc_rlimit_control_wakeupmon>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( proc_rlimit_control_wakeupmon ) ));
    assert_eq! (::std::mem::align_of::<proc_rlimit_control_wakeupmon>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( proc_rlimit_control_wakeupmon
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! (
                wm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_rate as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! ( wm_rate
                ) ));
}
impl Clone for proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(arg1: ::std::os::raw::c_int, arg2: id_t,
                       arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294901760u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294901760u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(w_Termsig: ::std::os::raw::c_uint,
                          w_Coredump: ::std::os::raw::c_uint,
                          w_Retcode: ::std::os::raw::c_uint,
                          w_Filler: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((w_Termsig as u32 as u32) << 0usize) &
                                (127u64 as u32))
                   } |
                       ((w_Coredump as u32 as u32) << 7usize) &
                           (128u64 as u32))
              } | ((w_Retcode as u32 as u32) << 8usize) & (65280u64 as u32))
         } | ((w_Filler as u32 as u32) << 16usize) & (4294901760u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294901760u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294901760u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(w_Stopval: ::std::os::raw::c_uint,
                          w_Stopsig: ::std::os::raw::c_uint,
                          w_Filler: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((w_Stopval as u32 as u32) << 0usize) &
                           (255u64 as u32))
              } | ((w_Stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
         } | ((w_Filler as u32 as u32) << 16usize) & (4294901760u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_T as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_T ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_S as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_S ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(arg1: *mut ::std::os::raw::c_int,
                 arg2: ::std::os::raw::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn wait4(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                 arg3: ::std::os::raw::c_int, arg4: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nel: usize,
                   __width: usize,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long)
     -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong,
                 arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                  arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                 __width: usize,
                 __compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtol(__str: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtoll(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(__str: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const *const ::std::os::raw::c_char,
                     arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(arg1: ::std::os::raw::c_uint,
                     arg2: *mut ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "realpath$DARWIN_EXTSN"]
    pub fn realpath(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __overwrite: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar,
                                arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void,
                          __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(__key: *const ::std::os::raw::c_void,
                     __base: *const ::std::os::raw::c_void, __nel: usize,
                     __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(arg1: *mut *mut ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(arg1: *const ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "daemon$1050"]
    pub fn daemon(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(arg1: dev_t, arg2: mode_t,
                     buf: *mut ::std::os::raw::c_char,
                     len: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(arg1: *mut ::std::os::raw::c_int,
                    arg2: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heapsort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                    __width: usize,
                    __compar:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                      __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                     __width: usize,
                     __compar:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                       __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                 __width: usize,
                 __compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn psort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, __compar: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn psort_r(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, arg1: *mut ::std::os::raw::c_void,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn qsort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, __compar: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn qsort_r(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, arg1: *mut ::std::os::raw::c_void,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn radixsort(__base: *mut *const ::std::os::raw::c_uchar,
                     __nel: ::std::os::raw::c_int,
                     __table: *const ::std::os::raw::c_uchar,
                     __endbyte: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sradixsort(__base: *mut *const ::std::os::raw::c_uchar,
                      __nel: ::std::os::raw::c_int,
                      __table: *const ::std::os::raw::c_uchar,
                      __endbyte: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtoq(__str: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type jmp_buf = [::std::os::raw::c_int; 37usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 38usize];
extern "C" {
    pub fn setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut ::std::os::raw::c_int,
                   arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _longjmp(arg1: *mut ::std::os::raw::c_int,
                    arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sigsetjmp(arg1: *mut ::std::os::raw::c_int,
                     arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siglongjmp(arg1: *mut ::std::os::raw::c_int,
                      arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn longjmperror();
}
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}

pub type FT_Int16 = ::std::os::raw::c_short;

pub type FT_UInt16 = ::std::os::raw::c_ushort;
pub type FT_Int32 = ::std::os::raw::c_int;
pub type FT_UInt32 = ::std::os::raw::c_uint;
pub type FT_Fast = ::std::os::raw::c_int;
pub type FT_UFast = ::std::os::raw::c_uint;
pub type FT_Int64 = ::std::os::raw::c_long;
pub type FT_UInt64 = ::std::os::raw::c_ulong;
/// @struct:
/// FT_MemoryRec
///
/// @description:
/// A structure used to describe a given memory manager to FreeType~2.
///
/// @fields:
/// user ::
/// A generic typeless pointer for user data.
///
/// alloc ::
/// A pointer type to an allocation function.
///
/// free ::
/// A pointer type to an memory freeing function.
///
/// realloc ::
/// A pointer type to a reallocation function.
///
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_MemoryRec_ {
    pub user: *mut ::std::os::raw::c_void,
    pub alloc: FT_Alloc_Func,
    pub free: FT_Free_Func,
    pub realloc: FT_Realloc_Func,
}
#[test]
fn bindgen_test_layout_FT_MemoryRec_() {
    assert_eq!(::std::mem::size_of::<FT_MemoryRec_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_MemoryRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_MemoryRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_MemoryRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . user as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . alloc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . free as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_MemoryRec_ ) ) . realloc as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_MemoryRec_ ) , "::"
                , stringify ! ( realloc ) ));
}
impl Clone for FT_MemoryRec_ {
    fn clone(&self) -> Self { *self }
}
/// @type:
/// FT_Memory
///
/// @description:
/// A handle to a given memory manager object, defined with an
/// @FT_MemoryRec structure.
///
pub type FT_Memory = *mut FT_MemoryRec_;
/// @functype:
/// FT_Alloc_Func
///
/// @description:
/// A function used to allocate `size' bytes from `memory'.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// size ::
/// The size in bytes to allocate.
///
/// @return:
/// Address of new memory block.  0~in case of failure.
///
pub type FT_Alloc_Func =
    ::std::option::Option<unsafe extern "C" fn(memory: FT_Memory,
                                               size: ::std::os::raw::c_long)
                              -> *mut ::std::os::raw::c_void>;
/// @functype:
/// FT_Free_Func
///
/// @description:
/// A function used to release a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// block ::
/// The address of the target memory block.
///
pub type FT_Free_Func =
    ::std::option::Option<unsafe extern "C" fn(memory: FT_Memory,
                                               block:
                                                   *mut ::std::os::raw::c_void)>;
/// @functype:
/// FT_Realloc_Func
///
/// @description:
/// A function used to re-allocate a given block of memory.
///
/// @input:
/// memory ::
/// A handle to the source memory manager.
///
/// cur_size ::
/// The block's current size in bytes.
///
/// new_size ::
/// The block's requested new size.
///
/// block ::
/// The block's current address.
///
/// @return:
/// New block address.  0~in case of memory shortage.
///
/// @note:
/// In case of error, the old block must still be available.
///
pub type FT_Realloc_Func =
    ::std::option::Option<unsafe extern "C" fn(memory: FT_Memory,
                                               cur_size:
                                                   ::std::os::raw::c_long,
                                               new_size:
                                                   ::std::os::raw::c_long,
                                               block:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
/// @struct:
/// FT_StreamRec
///
/// @description:
/// A structure used to describe an input stream.
///
/// @input:
/// base ::
/// For memory-based streams, this is the address of the first stream
/// byte in memory.  This field should always be set to NULL for
/// disk-based streams.
///
/// size ::
/// The stream size in bytes.
///
/// In case of compressed streams where the size is unknown before
/// actually doing the decompression, the value is set to 0x7FFFFFFF.
/// (Note that this size value can occur for normal streams also; it is
/// thus just a hint.)
///
/// pos ::
/// The current position within the stream.
///
/// descriptor ::
/// This field is a union that can hold an integer or a pointer.  It is
/// used by stream implementations to store file descriptors or `FILE*'
/// pointers.
///
/// pathname ::
/// This field is completely ignored by FreeType.  However, it is often
/// useful during debugging to use it to store the stream's filename
/// (where available).
///
/// read ::
/// The stream's input function.
///
/// close ::
/// The stream's close function.
///
/// memory ::
/// The memory manager to use to preload frames.  This is set
/// internally by FreeType and shouldn't be touched by stream
/// implementations.
///
/// cursor ::
/// This field is set and used internally by FreeType when parsing
/// frames.
///
/// limit ::
/// This field is set and used internally by FreeType when parsing
/// frames.
///
#[repr(C)]
#[derive(Copy)]
pub struct FT_StreamRec_ {
    pub base: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_ulong,
    pub pos: ::std::os::raw::c_ulong,
    pub descriptor: FT_StreamDesc,
    pub pathname: FT_StreamDesc,
    pub read: FT_Stream_IoFunc,
    pub close: FT_Stream_CloseFunc,
    pub memory: FT_Memory,
    pub cursor: *mut ::std::os::raw::c_uchar,
    pub limit: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_FT_StreamRec_() {
    assert_eq!(::std::mem::size_of::<FT_StreamRec_>() , 80usize , concat ! (
               "Size of: " , stringify ! ( FT_StreamRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_StreamRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_StreamRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . descriptor as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . pathname as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( pathname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . read as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . close as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . memory as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . cursor as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamRec_ ) ) . limit as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamRec_ ) , "::"
                , stringify ! ( limit ) ));
}
impl Clone for FT_StreamRec_ {
    fn clone(&self) -> Self { *self }
}
/// @type:
/// FT_Stream
///
/// @description:
/// A handle to an input stream.
///
/// @also:
/// See @FT_StreamRec for the publicly accessible fields of a given
/// stream object.
///
pub type FT_Stream = *mut FT_StreamRec_;
/// @struct:
/// FT_StreamDesc
///
/// @description:
/// A union type used to store either a long or a pointer.  This is used
/// to store a file descriptor or a `FILE*' in an input stream.
///
#[repr(C)]
#[derive(Copy)]
pub union FT_StreamDesc_ {
    pub value: ::std::os::raw::c_long,
    pub pointer: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_FT_StreamDesc_() {
    assert_eq!(::std::mem::size_of::<FT_StreamDesc_>() , 8usize , concat ! (
               "Size of: " , stringify ! ( FT_StreamDesc_ ) ));
    assert_eq! (::std::mem::align_of::<FT_StreamDesc_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_StreamDesc_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamDesc_ ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamDesc_ ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_StreamDesc_ ) ) . pointer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_StreamDesc_ ) , "::"
                , stringify ! ( pointer ) ));
}
impl Clone for FT_StreamDesc_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_StreamDesc = FT_StreamDesc_;
/// @functype:
/// FT_Stream_IoFunc
///
/// @description:
/// A function used to seek and read data from a given input stream.
///
/// @input:
/// stream ::
/// A handle to the source stream.
///
/// offset ::
/// The offset of read in stream (always from start).
///
/// buffer ::
/// The address of the read buffer.
///
/// count ::
/// The number of bytes to read from the stream.
///
/// @return:
/// The number of bytes effectively read by the stream.
///
/// @note:
/// This function might be called to perform a seek or skip operation
/// with a `count' of~0.  A non-zero return value then indicates an
/// error.
///
pub type FT_Stream_IoFunc =
    ::std::option::Option<unsafe extern "C" fn(stream: FT_Stream,
                                               offset:
                                                   ::std::os::raw::c_ulong,
                                               buffer:
                                                   *mut ::std::os::raw::c_uchar,
                                               count: ::std::os::raw::c_ulong)
                              -> ::std::os::raw::c_ulong>;
/// @functype:
/// FT_Stream_CloseFunc
///
/// @description:
/// A function used to close a given input stream.
///
/// @input:
/// stream ::
/// A handle to the target stream.
///
pub type FT_Stream_CloseFunc =
    ::std::option::Option<unsafe extern "C" fn(stream: FT_Stream)>;
pub type FT_StreamRec = FT_StreamRec_;

pub type FT_Pos = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Vector_ {
    pub x: FT_Pos,
    pub y: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Vector_() {
    assert_eq!(::std::mem::size_of::<FT_Vector_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Vector_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Vector_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Vector_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Vector_ ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Vector_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Vector_ ) ) . y as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Vector_ ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for FT_Vector_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Vector = FT_Vector_;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_BBox_ {
    pub xMin: FT_Pos,
    pub yMin: FT_Pos,
    pub xMax: FT_Pos,
    pub yMax: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_BBox_() {
    assert_eq!(::std::mem::size_of::<FT_BBox_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_BBox_ ) ));
    assert_eq! (::std::mem::align_of::<FT_BBox_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_BBox_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . xMin as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( xMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . yMin as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( yMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . xMax as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( xMax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BBox_ ) ) . yMax as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BBox_ ) , "::" ,
                stringify ! ( yMax ) ));
}
impl Clone for FT_BBox_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_BBox = FT_BBox_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Pixel_Mode_ {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO = 1,
    FT_PIXEL_MODE_GRAY = 2,
    FT_PIXEL_MODE_GRAY2 = 3,
    FT_PIXEL_MODE_GRAY4 = 4,
    FT_PIXEL_MODE_LCD = 5,
    FT_PIXEL_MODE_LCD_V = 6,
    FT_PIXEL_MODE_BGRA = 7,
    FT_PIXEL_MODE_MAX = 8,
}
pub use self::FT_Pixel_Mode_ as FT_Pixel_Mode;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Bitmap_ {
    pub rows: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub pitch: ::std::os::raw::c_int,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub num_grays: ::std::os::raw::c_ushort,
    pub pixel_mode: ::std::os::raw::c_uchar,
    pub palette_mode: ::std::os::raw::c_uchar,
    pub palette: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_() {
    assert_eq!(::std::mem::size_of::<FT_Bitmap_>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FT_Bitmap_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Bitmap_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Bitmap_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . rows as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( rows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . width as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . pitch as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . buffer as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . num_grays as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( num_grays ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . pixel_mode as * const _
                as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( pixel_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . palette_mode as * const
                _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( palette_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_ ) ) . palette as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_ ) , "::" ,
                stringify ! ( palette ) ));
}
impl Clone for FT_Bitmap_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Bitmap = FT_Bitmap_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Outline_ {
    pub n_contours: ::std::os::raw::c_short,
    pub n_points: ::std::os::raw::c_short,
    pub points: *mut FT_Vector,
    pub tags: *mut ::std::os::raw::c_char,
    pub contours: *mut ::std::os::raw::c_short,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FT_Outline_() {
    assert_eq!(::std::mem::size_of::<FT_Outline_>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FT_Outline_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Outline_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Outline_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . n_contours as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( n_contours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . n_points as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( n_points ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . points as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( points ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . tags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . contours as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( contours ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_ ) ) . flags as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_ ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for FT_Outline_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Outline = FT_Outline_;

pub type FT_Outline_MoveToFunc =
    ::std::option::Option<unsafe extern "C" fn(to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;

pub type FT_Outline_LineToFunc =
    ::std::option::Option<unsafe extern "C" fn(to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;

pub type FT_Outline_ConicToFunc =
    ::std::option::Option<unsafe extern "C" fn(control: *const FT_Vector,
                                               to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;

pub type FT_Outline_CubicToFunc =
    ::std::option::Option<unsafe extern "C" fn(control1: *const FT_Vector,
                                               control2: *const FT_Vector,
                                               to: *const FT_Vector,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Outline_Funcs_ {
    pub move_to: FT_Outline_MoveToFunc,
    pub line_to: FT_Outline_LineToFunc,
    pub conic_to: FT_Outline_ConicToFunc,
    pub cubic_to: FT_Outline_CubicToFunc,
    pub shift: ::std::os::raw::c_int,
    pub delta: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Outline_Funcs_() {
    assert_eq!(::std::mem::size_of::<FT_Outline_Funcs_>() , 48usize , concat !
               ( "Size of: " , stringify ! ( FT_Outline_Funcs_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Outline_Funcs_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FT_Outline_Funcs_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . move_to as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( move_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . line_to as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( line_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . conic_to as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( conic_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . cubic_to as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( cubic_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . shift as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Outline_Funcs_ ) ) . delta as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Outline_Funcs_ ) ,
                "::" , stringify ! ( delta ) ));
}
impl Clone for FT_Outline_Funcs_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Outline_Funcs = FT_Outline_Funcs_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Glyph_Format_ {
    FT_GLYPH_FORMAT_NONE = 0,
    FT_GLYPH_FORMAT_COMPOSITE = 1668246896,
    FT_GLYPH_FORMAT_BITMAP = 1651078259,
    FT_GLYPH_FORMAT_OUTLINE = 1869968492,
    FT_GLYPH_FORMAT_PLOTTER = 1886154612,
}
pub use self::FT_Glyph_Format_ as FT_Glyph_Format;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RasterRec_ {
    _unused: [u8; 0],
}

pub type FT_Raster = *mut FT_RasterRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Span_ {
    pub x: ::std::os::raw::c_short,
    pub len: ::std::os::raw::c_ushort,
    pub coverage: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_FT_Span_() {
    assert_eq!(::std::mem::size_of::<FT_Span_>() , 6usize , concat ! (
               "Size of: " , stringify ! ( FT_Span_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Span_>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( FT_Span_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Span_ ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Span_ ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Span_ ) ) . len as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Span_ ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Span_ ) ) . coverage as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Span_ ) , "::" ,
                stringify ! ( coverage ) ));
}
impl Clone for FT_Span_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Span = FT_Span_;

pub type FT_SpanFunc =
    ::std::option::Option<unsafe extern "C" fn(y: ::std::os::raw::c_int,
                                               count: ::std::os::raw::c_int,
                                               spans: *const FT_Span,
                                               user:
                                                   *mut ::std::os::raw::c_void)>;

pub type FT_Raster_BitTest_Func =
    ::std::option::Option<unsafe extern "C" fn(y: ::std::os::raw::c_int,
                                               x: ::std::os::raw::c_int,
                                               user:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;

pub type FT_Raster_BitSet_Func =
    ::std::option::Option<unsafe extern "C" fn(y: ::std::os::raw::c_int,
                                               x: ::std::os::raw::c_int,
                                               user:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Raster_Params_ {
    pub target: *const FT_Bitmap,
    pub source: *const ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_int,
    pub gray_spans: FT_SpanFunc,
    pub black_spans: FT_SpanFunc,
    pub bit_test: FT_Raster_BitTest_Func,
    pub bit_set: FT_Raster_BitSet_Func,
    pub user: *mut ::std::os::raw::c_void,
    pub clip_box: FT_BBox,
}
#[test]
fn bindgen_test_layout_FT_Raster_Params_() {
    assert_eq!(::std::mem::size_of::<FT_Raster_Params_>() , 96usize , concat !
               ( "Size of: " , stringify ! ( FT_Raster_Params_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Raster_Params_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FT_Raster_Params_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . target as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . source as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . gray_spans as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( gray_spans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . black_spans as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( black_spans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . bit_test as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( bit_test ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . bit_set as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( bit_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . user as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Params_ ) ) . clip_box as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Params_ ) ,
                "::" , stringify ! ( clip_box ) ));
}
impl Clone for FT_Raster_Params_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Raster_Params = FT_Raster_Params_;
pub type FT_Raster_NewFunc =
    ::std::option::Option<unsafe extern "C" fn(memory:
                                                   *mut ::std::os::raw::c_void,
                                               raster: *mut FT_Raster)
                              -> ::std::os::raw::c_int>;

pub type FT_Raster_DoneFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster)>;

pub type FT_Raster_ResetFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster,
                                               pool_base:
                                                   *mut ::std::os::raw::c_uchar,
                                               pool_size:
                                                   ::std::os::raw::c_ulong)>;

pub type FT_Raster_SetModeFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster,
                                               mode: ::std::os::raw::c_ulong,
                                               args:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type FT_Raster_RenderFunc =
    ::std::option::Option<unsafe extern "C" fn(raster: FT_Raster,
                                               params:
                                                   *const FT_Raster_Params)
                              -> ::std::os::raw::c_int>;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Raster_Funcs_ {
    pub glyph_format: FT_Glyph_Format,
    pub raster_new: FT_Raster_NewFunc,
    pub raster_reset: FT_Raster_ResetFunc,
    pub raster_set_mode: FT_Raster_SetModeFunc,
    pub raster_render: FT_Raster_RenderFunc,
    pub raster_done: FT_Raster_DoneFunc,
}
#[test]
fn bindgen_test_layout_FT_Raster_Funcs_() {
    assert_eq!(::std::mem::size_of::<FT_Raster_Funcs_>() , 48usize , concat !
               ( "Size of: " , stringify ! ( FT_Raster_Funcs_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Raster_Funcs_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_Raster_Funcs_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . glyph_format as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( glyph_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_new as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_new ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_reset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_set_mode as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_set_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_render as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_render ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Raster_Funcs_ ) ) . raster_done as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Raster_Funcs_ ) ,
                "::" , stringify ! ( raster_done ) ));
}
impl Clone for FT_Raster_Funcs_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Raster_Funcs = FT_Raster_Funcs_;

pub type FT_Bool = ::std::os::raw::c_uchar;

pub type FT_FWord = ::std::os::raw::c_short;

pub type FT_UFWord = ::std::os::raw::c_ushort;

pub type FT_Char = ::std::os::raw::c_schar;

pub type FT_Byte = ::std::os::raw::c_uchar;

pub type FT_Bytes = *const FT_Byte;

pub type FT_Tag = FT_UInt32;

pub type FT_String = ::std::os::raw::c_char;

pub type FT_Short = ::std::os::raw::c_short;

pub type FT_UShort = ::std::os::raw::c_ushort;

pub type FT_Int = ::std::os::raw::c_int;

pub type FT_UInt = ::std::os::raw::c_uint;

pub type FT_Long = ::std::os::raw::c_long;

pub type FT_ULong = ::std::os::raw::c_ulong;

pub type FT_F2Dot14 = ::std::os::raw::c_short;

pub type FT_F26Dot6 = ::std::os::raw::c_long;

pub type FT_Fixed = ::std::os::raw::c_long;

pub type FT_Error = ::std::os::raw::c_int;

pub type FT_Pointer = *mut ::std::os::raw::c_void;

pub type FT_Offset = usize;

pub type FT_PtrDist = isize;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_UnitVector_ {
    pub x: FT_F2Dot14,
    pub y: FT_F2Dot14,
}
#[test]
fn bindgen_test_layout_FT_UnitVector_() {
    assert_eq!(::std::mem::size_of::<FT_UnitVector_>() , 4usize , concat ! (
               "Size of: " , stringify ! ( FT_UnitVector_ ) ));
    assert_eq! (::std::mem::align_of::<FT_UnitVector_>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( FT_UnitVector_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_UnitVector_ ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_UnitVector_ ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_UnitVector_ ) ) . y as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_UnitVector_ ) , "::"
                , stringify ! ( y ) ));
}
impl Clone for FT_UnitVector_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_UnitVector = FT_UnitVector_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Matrix_ {
    pub xx: FT_Fixed,
    pub xy: FT_Fixed,
    pub yx: FT_Fixed,
    pub yy: FT_Fixed,
}
#[test]
fn bindgen_test_layout_FT_Matrix_() {
    assert_eq!(::std::mem::size_of::<FT_Matrix_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_Matrix_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Matrix_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Matrix_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . xx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( xx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . xy as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( xy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . yx as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( yx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Matrix_ ) ) . yy as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Matrix_ ) , "::" ,
                stringify ! ( yy ) ));
}
impl Clone for FT_Matrix_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Matrix = FT_Matrix_;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Data_ {
    pub pointer: *const FT_Byte,
    pub length: FT_Int,
}
#[test]
fn bindgen_test_layout_FT_Data_() {
    assert_eq!(::std::mem::size_of::<FT_Data_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Data_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Data_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Data_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Data_ ) ) . pointer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Data_ ) , "::" ,
                stringify ! ( pointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Data_ ) ) . length as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Data_ ) , "::" ,
                stringify ! ( length ) ));
}
impl Clone for FT_Data_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Data = FT_Data_;
pub type FT_Generic_Finalizer =
    ::std::option::Option<unsafe extern "C" fn(object:
                                                   *mut ::std::os::raw::c_void)>;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Generic_ {
    pub data: *mut ::std::os::raw::c_void,
    pub finalizer: FT_Generic_Finalizer,
}
#[test]
fn bindgen_test_layout_FT_Generic_() {
    assert_eq!(::std::mem::size_of::<FT_Generic_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Generic_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Generic_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Generic_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Generic_ ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Generic_ ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Generic_ ) ) . finalizer as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Generic_ ) , "::" ,
                stringify ! ( finalizer ) ));
}
impl Clone for FT_Generic_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Generic = FT_Generic_;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_ListNodeRec_ {
    pub prev: FT_ListNode,
    pub next: FT_ListNode,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_ListNodeRec_() {
    assert_eq!(::std::mem::size_of::<FT_ListNodeRec_>() , 24usize , concat ! (
               "Size of: " , stringify ! ( FT_ListNodeRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_ListNodeRec_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_ListNodeRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListNodeRec_ ) ) . prev as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListNodeRec_ ) ,
                "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListNodeRec_ ) ) . next as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListNodeRec_ ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListNodeRec_ ) ) . data as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListNodeRec_ ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for FT_ListNodeRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_ListNode = *mut FT_ListNodeRec_;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_ListRec_ {
    pub head: FT_ListNode,
    pub tail: FT_ListNode,
}
#[test]
fn bindgen_test_layout_FT_ListRec_() {
    assert_eq!(::std::mem::size_of::<FT_ListRec_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_ListRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_ListRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_ListRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListRec_ ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListRec_ ) , "::" ,
                stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_ListRec_ ) ) . tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_ListRec_ ) , "::" ,
                stringify ! ( tail ) ));
}
impl Clone for FT_ListRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_List = *mut FT_ListRec_;
pub type FT_ListNodeRec = FT_ListNodeRec_;
pub type FT_ListRec = FT_ListRec_;
pub const FT_Mod_Err_Base: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Autofit: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_BDF: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Bzip2: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Cache: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_CFF: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_CID: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Gzip: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_LZW: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_OTvalid: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PCF: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PFR: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PSaux: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PShinter: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_PSnames: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Raster: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_SFNT: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Smooth: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_TrueType: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Type1: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Type42: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Winfonts: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_GXvalid: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Base;
pub const FT_Mod_Err_Max: _bindgen_ty_1 = _bindgen_ty_1::FT_Mod_Err_Max;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 { FT_Mod_Err_Base = 0, FT_Mod_Err_Max = 1, }
pub const FT_Err_Ok: _bindgen_ty_2 = _bindgen_ty_2::FT_Err_Ok;
pub const FT_Err_Cannot_Open_Resource: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Cannot_Open_Resource;
pub const FT_Err_Unknown_File_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Unknown_File_Format;
pub const FT_Err_Invalid_File_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_File_Format;
pub const FT_Err_Invalid_Version: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Version;
pub const FT_Err_Lower_Module_Version: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Lower_Module_Version;
pub const FT_Err_Invalid_Argument: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Argument;
pub const FT_Err_Unimplemented_Feature: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Unimplemented_Feature;
pub const FT_Err_Invalid_Table: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Table;
pub const FT_Err_Invalid_Offset: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Offset;
pub const FT_Err_Array_Too_Large: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Array_Too_Large;
pub const FT_Err_Missing_Module: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Module;
pub const FT_Err_Missing_Property: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Property;
pub const FT_Err_Invalid_Glyph_Index: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Glyph_Index;
pub const FT_Err_Invalid_Character_Code: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Character_Code;
pub const FT_Err_Invalid_Glyph_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Glyph_Format;
pub const FT_Err_Cannot_Render_Glyph: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Cannot_Render_Glyph;
pub const FT_Err_Invalid_Outline: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Outline;
pub const FT_Err_Invalid_Composite: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Composite;
pub const FT_Err_Too_Many_Hints: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Hints;
pub const FT_Err_Invalid_Pixel_Size: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Pixel_Size;
pub const FT_Err_Invalid_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Handle;
pub const FT_Err_Invalid_Library_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Library_Handle;
pub const FT_Err_Invalid_Driver_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Driver_Handle;
pub const FT_Err_Invalid_Face_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Face_Handle;
pub const FT_Err_Invalid_Size_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Size_Handle;
pub const FT_Err_Invalid_Slot_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Slot_Handle;
pub const FT_Err_Invalid_CharMap_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_CharMap_Handle;
pub const FT_Err_Invalid_Cache_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Cache_Handle;
pub const FT_Err_Invalid_Stream_Handle: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Handle;
pub const FT_Err_Too_Many_Drivers: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Drivers;
pub const FT_Err_Too_Many_Extensions: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Extensions;
pub const FT_Err_Out_Of_Memory: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Out_Of_Memory;
pub const FT_Err_Unlisted_Object: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Unlisted_Object;
pub const FT_Err_Cannot_Open_Stream: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Cannot_Open_Stream;
pub const FT_Err_Invalid_Stream_Seek: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Seek;
pub const FT_Err_Invalid_Stream_Skip: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Skip;
pub const FT_Err_Invalid_Stream_Read: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Read;
pub const FT_Err_Invalid_Stream_Operation: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Stream_Operation;
pub const FT_Err_Invalid_Frame_Operation: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Frame_Operation;
pub const FT_Err_Nested_Frame_Access: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Nested_Frame_Access;
pub const FT_Err_Invalid_Frame_Read: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Frame_Read;
pub const FT_Err_Raster_Uninitialized: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Uninitialized;
pub const FT_Err_Raster_Corrupted: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Corrupted;
pub const FT_Err_Raster_Overflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Overflow;
pub const FT_Err_Raster_Negative_Height: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Raster_Negative_Height;
pub const FT_Err_Too_Many_Caches: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Caches;
pub const FT_Err_Invalid_Opcode: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Opcode;
pub const FT_Err_Too_Few_Arguments: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Few_Arguments;
pub const FT_Err_Stack_Overflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Stack_Overflow;
pub const FT_Err_Code_Overflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Code_Overflow;
pub const FT_Err_Bad_Argument: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Bad_Argument;
pub const FT_Err_Divide_By_Zero: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Divide_By_Zero;
pub const FT_Err_Invalid_Reference: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Reference;
pub const FT_Err_Debug_OpCode: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Debug_OpCode;
pub const FT_Err_ENDF_In_Exec_Stream: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_ENDF_In_Exec_Stream;
pub const FT_Err_Nested_DEFS: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Nested_DEFS;
pub const FT_Err_Invalid_CodeRange: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_CodeRange;
pub const FT_Err_Execution_Too_Long: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Execution_Too_Long;
pub const FT_Err_Too_Many_Function_Defs: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Function_Defs;
pub const FT_Err_Too_Many_Instruction_Defs: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Too_Many_Instruction_Defs;
pub const FT_Err_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Table_Missing;
pub const FT_Err_Horiz_Header_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Horiz_Header_Missing;
pub const FT_Err_Locations_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Locations_Missing;
pub const FT_Err_Name_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Name_Table_Missing;
pub const FT_Err_CMap_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_CMap_Table_Missing;
pub const FT_Err_Hmtx_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Hmtx_Table_Missing;
pub const FT_Err_Post_Table_Missing: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Post_Table_Missing;
pub const FT_Err_Invalid_Horiz_Metrics: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Horiz_Metrics;
pub const FT_Err_Invalid_CharMap_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_CharMap_Format;
pub const FT_Err_Invalid_PPem: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_PPem;
pub const FT_Err_Invalid_Vert_Metrics: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Vert_Metrics;
pub const FT_Err_Could_Not_Find_Context: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Could_Not_Find_Context;
pub const FT_Err_Invalid_Post_Table_Format: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Post_Table_Format;
pub const FT_Err_Invalid_Post_Table: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Invalid_Post_Table;
pub const FT_Err_DEF_In_Glyf_Bytecode: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_DEF_In_Glyf_Bytecode;
pub const FT_Err_Missing_Bitmap: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Bitmap;
pub const FT_Err_Syntax_Error: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Syntax_Error;
pub const FT_Err_Stack_Underflow: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Stack_Underflow;
pub const FT_Err_Ignore: _bindgen_ty_2 = _bindgen_ty_2::FT_Err_Ignore;
pub const FT_Err_No_Unicode_Glyph_Name: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_No_Unicode_Glyph_Name;
pub const FT_Err_Glyph_Too_Big: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Glyph_Too_Big;
pub const FT_Err_Missing_Startfont_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Startfont_Field;
pub const FT_Err_Missing_Font_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Font_Field;
pub const FT_Err_Missing_Size_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Size_Field;
pub const FT_Err_Missing_Fontboundingbox_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Fontboundingbox_Field;
pub const FT_Err_Missing_Chars_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Chars_Field;
pub const FT_Err_Missing_Startchar_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Startchar_Field;
pub const FT_Err_Missing_Encoding_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Encoding_Field;
pub const FT_Err_Missing_Bbx_Field: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Missing_Bbx_Field;
pub const FT_Err_Bbx_Too_Big: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Bbx_Too_Big;
pub const FT_Err_Corrupted_Font_Header: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Corrupted_Font_Header;
pub const FT_Err_Corrupted_Font_Glyphs: _bindgen_ty_2 =
    _bindgen_ty_2::FT_Err_Corrupted_Font_Glyphs;
pub const FT_Err_Max: _bindgen_ty_2 = _bindgen_ty_2::FT_Err_Max;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    FT_Err_Ok = 0,
    FT_Err_Cannot_Open_Resource = 1,
    FT_Err_Unknown_File_Format = 2,
    FT_Err_Invalid_File_Format = 3,
    FT_Err_Invalid_Version = 4,
    FT_Err_Lower_Module_Version = 5,
    FT_Err_Invalid_Argument = 6,
    FT_Err_Unimplemented_Feature = 7,
    FT_Err_Invalid_Table = 8,
    FT_Err_Invalid_Offset = 9,
    FT_Err_Array_Too_Large = 10,
    FT_Err_Missing_Module = 11,
    FT_Err_Missing_Property = 12,
    FT_Err_Invalid_Glyph_Index = 16,
    FT_Err_Invalid_Character_Code = 17,
    FT_Err_Invalid_Glyph_Format = 18,
    FT_Err_Cannot_Render_Glyph = 19,
    FT_Err_Invalid_Outline = 20,
    FT_Err_Invalid_Composite = 21,
    FT_Err_Too_Many_Hints = 22,
    FT_Err_Invalid_Pixel_Size = 23,
    FT_Err_Invalid_Handle = 32,
    FT_Err_Invalid_Library_Handle = 33,
    FT_Err_Invalid_Driver_Handle = 34,
    FT_Err_Invalid_Face_Handle = 35,
    FT_Err_Invalid_Size_Handle = 36,
    FT_Err_Invalid_Slot_Handle = 37,
    FT_Err_Invalid_CharMap_Handle = 38,
    FT_Err_Invalid_Cache_Handle = 39,
    FT_Err_Invalid_Stream_Handle = 40,
    FT_Err_Too_Many_Drivers = 48,
    FT_Err_Too_Many_Extensions = 49,
    FT_Err_Out_Of_Memory = 64,
    FT_Err_Unlisted_Object = 65,
    FT_Err_Cannot_Open_Stream = 81,
    FT_Err_Invalid_Stream_Seek = 82,
    FT_Err_Invalid_Stream_Skip = 83,
    FT_Err_Invalid_Stream_Read = 84,
    FT_Err_Invalid_Stream_Operation = 85,
    FT_Err_Invalid_Frame_Operation = 86,
    FT_Err_Nested_Frame_Access = 87,
    FT_Err_Invalid_Frame_Read = 88,
    FT_Err_Raster_Uninitialized = 96,
    FT_Err_Raster_Corrupted = 97,
    FT_Err_Raster_Overflow = 98,
    FT_Err_Raster_Negative_Height = 99,
    FT_Err_Too_Many_Caches = 112,
    FT_Err_Invalid_Opcode = 128,
    FT_Err_Too_Few_Arguments = 129,
    FT_Err_Stack_Overflow = 130,
    FT_Err_Code_Overflow = 131,
    FT_Err_Bad_Argument = 132,
    FT_Err_Divide_By_Zero = 133,
    FT_Err_Invalid_Reference = 134,
    FT_Err_Debug_OpCode = 135,
    FT_Err_ENDF_In_Exec_Stream = 136,
    FT_Err_Nested_DEFS = 137,
    FT_Err_Invalid_CodeRange = 138,
    FT_Err_Execution_Too_Long = 139,
    FT_Err_Too_Many_Function_Defs = 140,
    FT_Err_Too_Many_Instruction_Defs = 141,
    FT_Err_Table_Missing = 142,
    FT_Err_Horiz_Header_Missing = 143,
    FT_Err_Locations_Missing = 144,
    FT_Err_Name_Table_Missing = 145,
    FT_Err_CMap_Table_Missing = 146,
    FT_Err_Hmtx_Table_Missing = 147,
    FT_Err_Post_Table_Missing = 148,
    FT_Err_Invalid_Horiz_Metrics = 149,
    FT_Err_Invalid_CharMap_Format = 150,
    FT_Err_Invalid_PPem = 151,
    FT_Err_Invalid_Vert_Metrics = 152,
    FT_Err_Could_Not_Find_Context = 153,
    FT_Err_Invalid_Post_Table_Format = 154,
    FT_Err_Invalid_Post_Table = 155,
    FT_Err_DEF_In_Glyf_Bytecode = 156,
    FT_Err_Missing_Bitmap = 157,
    FT_Err_Syntax_Error = 160,
    FT_Err_Stack_Underflow = 161,
    FT_Err_Ignore = 162,
    FT_Err_No_Unicode_Glyph_Name = 163,
    FT_Err_Glyph_Too_Big = 164,
    FT_Err_Missing_Startfont_Field = 176,
    FT_Err_Missing_Font_Field = 177,
    FT_Err_Missing_Size_Field = 178,
    FT_Err_Missing_Fontboundingbox_Field = 179,
    FT_Err_Missing_Chars_Field = 180,
    FT_Err_Missing_Startchar_Field = 181,
    FT_Err_Missing_Encoding_Field = 182,
    FT_Err_Missing_Bbx_Field = 183,
    FT_Err_Bbx_Too_Big = 184,
    FT_Err_Corrupted_Font_Header = 185,
    FT_Err_Corrupted_Font_Glyphs = 186,
    FT_Err_Max = 187,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Glyph_Metrics_ {
    pub width: FT_Pos,
    pub height: FT_Pos,
    pub horiBearingX: FT_Pos,
    pub horiBearingY: FT_Pos,
    pub horiAdvance: FT_Pos,
    pub vertBearingX: FT_Pos,
    pub vertBearingY: FT_Pos,
    pub vertAdvance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Glyph_Metrics_() {
    assert_eq!(::std::mem::size_of::<FT_Glyph_Metrics_>() , 64usize , concat !
               ( "Size of: " , stringify ! ( FT_Glyph_Metrics_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Glyph_Metrics_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FT_Glyph_Metrics_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . width as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . height as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . horiBearingX as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( horiBearingX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . horiBearingY as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( horiBearingY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . horiAdvance as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( horiAdvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . vertBearingX as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( vertBearingX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . vertBearingY as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( vertBearingY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Glyph_Metrics_ ) ) . vertAdvance as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Glyph_Metrics_ ) ,
                "::" , stringify ! ( vertAdvance ) ));
}
impl Clone for FT_Glyph_Metrics_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Glyph_Metrics = FT_Glyph_Metrics_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Bitmap_Size_ {
    pub height: FT_Short,
    pub width: FT_Short,
    pub size: FT_Pos,
    pub x_ppem: FT_Pos,
    pub y_ppem: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_Size_() {
    assert_eq!(::std::mem::size_of::<FT_Bitmap_Size_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FT_Bitmap_Size_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Bitmap_Size_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_Bitmap_Size_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . height as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . width as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . x_ppem as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( x_ppem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Bitmap_Size_ ) ) . y_ppem as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Bitmap_Size_ ) ,
                "::" , stringify ! ( y_ppem ) ));
}
impl Clone for FT_Bitmap_Size_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Bitmap_Size = FT_Bitmap_Size_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_LibraryRec_ {
    _unused: [u8; 0],
}
pub type FT_Library = *mut FT_LibraryRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ModuleRec_ {
    _unused: [u8; 0],
}

pub type FT_Module = *mut FT_ModuleRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_DriverRec_ {
    _unused: [u8; 0],
}

pub type FT_Driver = *mut FT_DriverRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_RendererRec_ {
    _unused: [u8; 0],
}

pub type FT_Renderer = *mut FT_RendererRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_FaceRec_ {
    pub num_faces: FT_Long,
    pub face_index: FT_Long,
    pub face_flags: FT_Long,
    pub style_flags: FT_Long,
    pub num_glyphs: FT_Long,
    pub family_name: *mut FT_String,
    pub style_name: *mut FT_String,
    pub num_fixed_sizes: FT_Int,
    pub available_sizes: *mut FT_Bitmap_Size,
    pub num_charmaps: FT_Int,
    pub charmaps: *mut FT_CharMap,
    pub generic: FT_Generic,
    pub bbox: FT_BBox,
    pub units_per_EM: FT_UShort,
    pub ascender: FT_Short,
    pub descender: FT_Short,
    pub height: FT_Short,
    pub max_advance_width: FT_Short,
    pub max_advance_height: FT_Short,
    pub underline_position: FT_Short,
    pub underline_thickness: FT_Short,
    pub glyph: FT_GlyphSlot,
    pub size: FT_Size,
    pub charmap: FT_CharMap,
    pub driver: FT_Driver,
    pub memory: FT_Memory,
    pub stream: FT_Stream,
    pub sizes_list: FT_ListRec,
    pub autohint: FT_Generic,
    pub extensions: *mut ::std::os::raw::c_void,
    pub internal: FT_Face_Internal,
}
#[test]
fn bindgen_test_layout_FT_FaceRec_() {
    assert_eq!(::std::mem::size_of::<FT_FaceRec_>() , 248usize , concat ! (
               "Size of: " , stringify ! ( FT_FaceRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_FaceRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_FaceRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_faces as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_faces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . face_index as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( face_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . face_flags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( face_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . style_flags as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( style_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_glyphs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_glyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . family_name as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( family_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . style_name as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( style_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_fixed_sizes as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_fixed_sizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . available_sizes as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( available_sizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . num_charmaps as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( num_charmaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . charmaps as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( charmaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . generic as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . bbox as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( bbox ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . units_per_EM as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( units_per_EM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . ascender as * const _
                as usize } , 138usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( ascender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . descender as * const _
                as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( descender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . height as * const _ as
                usize } , 142usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . max_advance_width as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( max_advance_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . max_advance_height as *
                const _ as usize } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( max_advance_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . underline_position as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( underline_position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . underline_thickness as
                * const _ as usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( underline_thickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . glyph as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( glyph ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . size as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . charmap as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( charmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . driver as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . memory as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . stream as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . sizes_list as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( sizes_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . autohint as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( autohint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . extensions as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( extensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_FaceRec_ ) ) . internal as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_FaceRec_ ) , "::" ,
                stringify ! ( internal ) ));
}
impl Clone for FT_FaceRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Face = *mut FT_FaceRec_;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_SizeRec_ {
    pub face: FT_Face,
    pub generic: FT_Generic,
    pub metrics: FT_Size_Metrics,
    pub internal: FT_Size_Internal,
}
#[test]
fn bindgen_test_layout_FT_SizeRec_() {
    assert_eq!(::std::mem::size_of::<FT_SizeRec_>() , 88usize , concat ! (
               "Size of: " , stringify ! ( FT_SizeRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_SizeRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_SizeRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . face as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( face ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . generic as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . metrics as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( metrics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_SizeRec_ ) ) . internal as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_SizeRec_ ) , "::" ,
                stringify ! ( internal ) ));
}
impl Clone for FT_SizeRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Size = *mut FT_SizeRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_GlyphSlotRec_ {
    pub library: FT_Library,
    pub face: FT_Face,
    pub next: FT_GlyphSlot,
    pub reserved: FT_UInt,
    pub generic: FT_Generic,
    pub metrics: FT_Glyph_Metrics,
    pub linearHoriAdvance: FT_Fixed,
    pub linearVertAdvance: FT_Fixed,
    pub advance: FT_Vector,
    pub format: FT_Glyph_Format,
    pub bitmap: FT_Bitmap,
    pub bitmap_left: FT_Int,
    pub bitmap_top: FT_Int,
    pub outline: FT_Outline,
    pub num_subglyphs: FT_UInt,
    pub subglyphs: FT_SubGlyph,
    pub control_data: *mut ::std::os::raw::c_void,
    pub control_len: ::std::os::raw::c_long,
    pub lsb_delta: FT_Pos,
    pub rsb_delta: FT_Pos,
    pub other: *mut ::std::os::raw::c_void,
    pub internal: FT_Slot_Internal,
}
#[test]
fn bindgen_test_layout_FT_GlyphSlotRec_() {
    assert_eq!(::std::mem::size_of::<FT_GlyphSlotRec_>() , 304usize , concat !
               ( "Size of: " , stringify ! ( FT_GlyphSlotRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_GlyphSlotRec_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_GlyphSlotRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . library as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( library ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . face as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( face ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . next as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . reserved as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . generic as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( generic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . metrics as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( metrics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . linearHoriAdvance
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( linearHoriAdvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . linearVertAdvance
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( linearVertAdvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . advance as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( advance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . format as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . bitmap as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( bitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . bitmap_left as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( bitmap_left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . bitmap_top as *
                const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( bitmap_top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . outline as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( outline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . num_subglyphs as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( num_subglyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . subglyphs as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( subglyphs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . control_data as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( control_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . control_len as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( control_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . lsb_delta as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( lsb_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . rsb_delta as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( rsb_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . other as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( other ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphSlotRec_ ) ) . internal as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphSlotRec_ ) ,
                "::" , stringify ! ( internal ) ));
}
impl Clone for FT_GlyphSlotRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_GlyphSlot = *mut FT_GlyphSlotRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_CharMapRec_ {
    pub face: FT_Face,
    pub encoding: FT_Encoding,
    pub platform_id: FT_UShort,
    pub encoding_id: FT_UShort,
}
#[test]
fn bindgen_test_layout_FT_CharMapRec_() {
    assert_eq!(::std::mem::size_of::<FT_CharMapRec_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_CharMapRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_CharMapRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_CharMapRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . face as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( face ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . encoding as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( encoding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . platform_id as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( platform_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_CharMapRec_ ) ) . encoding_id as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_CharMapRec_ ) , "::"
                , stringify ! ( encoding_id ) ));
}
impl Clone for FT_CharMapRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_CharMap = *mut FT_CharMapRec_;
pub const FT_Encoding__FT_ENCODING_GB2312: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_PRC;
pub const FT_Encoding__FT_ENCODING_MS_SJIS: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_SJIS;
pub const FT_Encoding__FT_ENCODING_MS_GB2312: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_PRC;
pub const FT_Encoding__FT_ENCODING_MS_BIG5: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_BIG5;
pub const FT_Encoding__FT_ENCODING_MS_WANSUNG: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_WANSUNG;
pub const FT_Encoding__FT_ENCODING_MS_JOHAB: FT_Encoding_ =
    FT_Encoding_::FT_ENCODING_JOHAB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Encoding_ {
    FT_ENCODING_NONE = 0,
    FT_ENCODING_MS_SYMBOL = 1937337698,
    FT_ENCODING_UNICODE = 1970170211,
    FT_ENCODING_SJIS = 1936353651,
    FT_ENCODING_PRC = 1734484000,
    FT_ENCODING_BIG5 = 1651074869,
    FT_ENCODING_WANSUNG = 2002873971,
    FT_ENCODING_JOHAB = 1785686113,
    FT_ENCODING_ADOBE_STANDARD = 1094995778,
    FT_ENCODING_ADOBE_EXPERT = 1094992453,
    FT_ENCODING_ADOBE_CUSTOM = 1094992451,
    FT_ENCODING_ADOBE_LATIN_1 = 1818326065,
    FT_ENCODING_OLD_LATIN_2 = 1818326066,
    FT_ENCODING_APPLE_ROMAN = 1634889070,
}
pub use self::FT_Encoding_ as FT_Encoding;
pub type FT_CharMapRec = FT_CharMapRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Face_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Face_Internal = *mut FT_Face_InternalRec_;
pub type FT_FaceRec = FT_FaceRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Size_Internal = *mut FT_Size_InternalRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Size_Metrics_ {
    pub x_ppem: FT_UShort,
    pub y_ppem: FT_UShort,
    pub x_scale: FT_Fixed,
    pub y_scale: FT_Fixed,
    pub ascender: FT_Pos,
    pub descender: FT_Pos,
    pub height: FT_Pos,
    pub max_advance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Size_Metrics_() {
    assert_eq!(::std::mem::size_of::<FT_Size_Metrics_>() , 56usize , concat !
               ( "Size of: " , stringify ! ( FT_Size_Metrics_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Size_Metrics_>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( FT_Size_Metrics_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . x_ppem as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( x_ppem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . y_ppem as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( y_ppem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . x_scale as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( x_scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . y_scale as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( y_scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . ascender as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( ascender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . descender as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( descender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . height as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_Metrics_ ) ) . max_advance as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_Metrics_ ) ,
                "::" , stringify ! ( max_advance ) ));
}
impl Clone for FT_Size_Metrics_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Size_Metrics = FT_Size_Metrics_;
pub type FT_SizeRec = FT_SizeRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SubGlyphRec_ {
    _unused: [u8; 0],
}
pub type FT_SubGlyph = *mut FT_SubGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Slot_InternalRec_ {
    _unused: [u8; 0],
}
pub type FT_Slot_Internal = *mut FT_Slot_InternalRec_;
pub type FT_GlyphSlotRec = FT_GlyphSlotRec_;
extern "C" {
    pub fn FT_Init_FreeType(alibrary: *mut FT_Library) -> FT_Error;
}
extern "C" {
    
    pub fn FT_Done_FreeType(library: FT_Library) -> FT_Error;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Parameter_ {
    pub tag: FT_ULong,
    pub data: FT_Pointer,
}
#[test]
fn bindgen_test_layout_FT_Parameter_() {
    assert_eq!(::std::mem::size_of::<FT_Parameter_>() , 16usize , concat ! (
               "Size of: " , stringify ! ( FT_Parameter_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Parameter_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Parameter_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Parameter_ ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Parameter_ ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Parameter_ ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Parameter_ ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for FT_Parameter_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Parameter = FT_Parameter_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Open_Args_ {
    pub flags: FT_UInt,
    pub memory_base: *const FT_Byte,
    pub memory_size: FT_Long,
    pub pathname: *mut FT_String,
    pub stream: FT_Stream,
    pub driver: FT_Module,
    pub num_params: FT_Int,
    pub params: *mut FT_Parameter,
}
#[test]
fn bindgen_test_layout_FT_Open_Args_() {
    assert_eq!(::std::mem::size_of::<FT_Open_Args_>() , 64usize , concat ! (
               "Size of: " , stringify ! ( FT_Open_Args_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Open_Args_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_Open_Args_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . memory_base as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( memory_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . memory_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( memory_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . pathname as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( pathname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . stream as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . driver as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . num_params as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( num_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Open_Args_ ) ) . params as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Open_Args_ ) , "::"
                , stringify ! ( params ) ));
}
impl Clone for FT_Open_Args_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Open_Args = FT_Open_Args_;
extern "C" {
    pub fn FT_New_Face(library: FT_Library,
                       filepathname: *const ::std::os::raw::c_char,
                       face_index: FT_Long, aface: *mut FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_New_Memory_Face(library: FT_Library, file_base: *const FT_Byte,
                              file_size: FT_Long, face_index: FT_Long,
                              aface: *mut FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Open_Face(library: FT_Library, args: *const FT_Open_Args,
                        face_index: FT_Long, aface: *mut FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Attach_File(face: FT_Face,
                          filepathname: *const ::std::os::raw::c_char)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Attach_Stream(face: FT_Face, parameters: *mut FT_Open_Args)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Reference_Face(face: FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Done_Face(face: FT_Face) -> FT_Error;
}
extern "C" {
    pub fn FT_Select_Size(face: FT_Face, strike_index: FT_Int) -> FT_Error;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Size_Request_Type_ {
    FT_SIZE_REQUEST_TYPE_NOMINAL = 0,
    FT_SIZE_REQUEST_TYPE_REAL_DIM = 1,
    FT_SIZE_REQUEST_TYPE_BBOX = 2,
    FT_SIZE_REQUEST_TYPE_CELL = 3,
    FT_SIZE_REQUEST_TYPE_SCALES = 4,
    FT_SIZE_REQUEST_TYPE_MAX = 5,
}
pub use self::FT_Size_Request_Type_ as FT_Size_Request_Type;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_Size_RequestRec_ {
    pub type_: FT_Size_Request_Type,
    pub width: FT_Long,
    pub height: FT_Long,
    pub horiResolution: FT_UInt,
    pub vertResolution: FT_UInt,
}
#[test]
fn bindgen_test_layout_FT_Size_RequestRec_() {
    assert_eq!(::std::mem::size_of::<FT_Size_RequestRec_>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( FT_Size_RequestRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_Size_RequestRec_>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FT_Size_RequestRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . width as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . height as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . horiResolution
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( horiResolution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_Size_RequestRec_ ) ) . vertResolution
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_Size_RequestRec_ ) ,
                "::" , stringify ! ( vertResolution ) ));
}
impl Clone for FT_Size_RequestRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Size_RequestRec = FT_Size_RequestRec_;

pub type FT_Size_Request = *mut FT_Size_RequestRec_;
extern "C" {
    pub fn FT_Request_Size(face: FT_Face, req: FT_Size_Request) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Char_Size(face: FT_Face, char_width: FT_F26Dot6,
                            char_height: FT_F26Dot6, horz_resolution: FT_UInt,
                            vert_resolution: FT_UInt) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Pixel_Sizes(face: FT_Face, pixel_width: FT_UInt,
                              pixel_height: FT_UInt) -> FT_Error;
}
extern "C" {
    pub fn FT_Load_Glyph(face: FT_Face, glyph_index: FT_UInt,
                         load_flags: FT_Int32) -> FT_Error;
}
extern "C" {
    pub fn FT_Load_Char(face: FT_Face, char_code: FT_ULong,
                        load_flags: FT_Int32) -> FT_Error;
}
extern "C" {
    pub fn FT_Set_Transform(face: FT_Face, matrix: *mut FT_Matrix,
                            delta: *mut FT_Vector);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Render_Mode_ {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT = 1,
    FT_RENDER_MODE_MONO = 2,
    FT_RENDER_MODE_LCD = 3,
    FT_RENDER_MODE_LCD_V = 4,
    FT_RENDER_MODE_MAX = 5,
}
pub use self::FT_Render_Mode_ as FT_Render_Mode;
extern "C" {
    pub fn FT_Render_Glyph(slot: FT_GlyphSlot, render_mode: FT_Render_Mode)
     -> FT_Error;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Kerning_Mode_ {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED = 1,
    FT_KERNING_UNSCALED = 2,
}
pub use self::FT_Kerning_Mode_ as FT_Kerning_Mode;
extern "C" {
    pub fn FT_Get_Kerning(face: FT_Face, left_glyph: FT_UInt,
                          right_glyph: FT_UInt, kern_mode: FT_UInt,
                          akerning: *mut FT_Vector) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Track_Kerning(face: FT_Face, point_size: FT_Fixed,
                                degree: FT_Int, akerning: *mut FT_Fixed)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Glyph_Name(face: FT_Face, glyph_index: FT_UInt,
                             buffer: FT_Pointer, buffer_max: FT_UInt)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Get_Postscript_Name(face: FT_Face)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FT_Select_Charmap(face: FT_Face, encoding: FT_Encoding)
     -> FT_Error;
}
extern "C" {
    
    pub fn FT_Set_Charmap(face: FT_Face, charmap: FT_CharMap) -> FT_Error;
}
extern "C" {
    /// @function:
/// FT_Get_Charmap_Index
///
/// @description:
/// Retrieve index of a given charmap.
///
/// @input:
/// charmap ::
/// A handle to a charmap.
///
/// @return:
/// The index into the array of character maps within the face to which
/// `charmap' belongs.  If an error occurs, -1 is returned.
///
    pub fn FT_Get_Charmap_Index(charmap: FT_CharMap) -> FT_Int;
}
extern "C" {
    
    pub fn FT_Get_Char_Index(face: FT_Face, charcode: FT_ULong) -> FT_UInt;
}
extern "C" {
    pub fn FT_Get_First_Char(face: FT_Face, agindex: *mut FT_UInt)
     -> FT_ULong;
}
extern "C" {
    pub fn FT_Get_Next_Char(face: FT_Face, char_code: FT_ULong,
                            agindex: *mut FT_UInt) -> FT_ULong;
}
extern "C" {
    /// @function:
/// FT_Face_Properties
///
/// @description:
/// Set or override certain (library or module-wide) properties on a
/// face-by-face basis.  Useful for finer-grained control and avoiding
/// locks on shared structures (threads can modify their own faces as
/// they see fit).
///
/// Contrary to @FT_Property_Set, this function uses @FT_Parameter so
/// that you can pass multiple properties to the target face in one call.
/// Note that only a subset of the available properties can be
/// controlled.
///
/// * Stem darkening (@FT_PARAM_TAG_STEM_DARKENING, corresponding to the
/// property `no-stem-darkening' provided by the `autofit' and `cff'
/// modules; see @no-stem-darkening[autofit] and
/// @no-stem-darkening[cff]).
///
/// * LCD filter weights (@FT_PARAM_TAG_LCD_FILTER_WEIGHTS, corresponding
/// to function @FT_Library_SetLcdFilterWeights).
///
/// * Seed value for the CFF `random' operator
/// (@FT_PARAM_TAG_RANDOM_SEED, corresponding to the `random-seed'
/// property provided by the `cff' module; see @random-seed).
///
/// Pass NULL as `data' in @FT_Parameter for a given tag to reset the
/// option and use the library or module default again.
///
/// @input:
/// face ::
/// A handle to the source face object.
///
/// num_properties ::
/// The number of properties that follow.
///
/// properties ::
/// A handle to an @FT_Parameter array with `num_properties' elements.
///
/// @return:
/// FreeType error code.  0~means success.
///
/// @note:
/// Here an example that sets three properties.  You must define
/// FT_CONFIG_OPTION_SUBPIXEL_RENDERING to make the LCD filter examples
/// work.
///
/// {
/// FT_Parameter         property1;
/// FT_Bool              darken_stems = 1;
///
/// FT_Parameter         property2;
/// FT_LcdFiveTapFilter  custom_weight =
/// { 0x11, 0x44, 0x56, 0x44, 0x11 };
///
/// FT_Parameter         property3;
/// FT_Int32             random_seed = 314159265;
///
/// FT_Parameter         properties[3] = { property1,
/// property2,
/// property3 };
///
///
/// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;
/// property1.data = &darken_stems;
///
/// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
/// property2.data = custom_weight;
///
/// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;
/// property3.data = &random_seed;
///
/// FT_Face_Properties( face, 3, properties );
/// }
///
/// The next example resets a single property to its default value.
///
/// {
/// FT_Parameter  property;
///
///
/// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
/// property.data = NULL;
///
/// FT_Face_Properties( face, 1, &property );
/// }
///
    pub fn FT_Face_Properties(face: FT_Face, num_properties: FT_UInt,
                              properties: *mut FT_Parameter) -> FT_Error;
}
extern "C" {
    
    pub fn FT_Get_Name_Index(face: FT_Face, glyph_name: *mut FT_String)
     -> FT_UInt;
}
extern "C" {
    /// @func:
/// FT_Get_SubGlyph_Info
///
/// @description:
/// Retrieve a description of a given subglyph.  Only use it if
/// `glyph->format' is @FT_GLYPH_FORMAT_COMPOSITE; an error is
/// returned otherwise.
///
/// @input:
/// glyph ::
/// The source glyph slot.
///
/// sub_index ::
/// The index of the subglyph.  Must be less than
/// `glyph->num_subglyphs'.
///
/// @output:
/// p_index ::
/// The glyph index of the subglyph.
///
/// p_flags ::
/// The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
///
/// p_arg1 ::
/// The subglyph's first argument (if any).
///
/// p_arg2 ::
/// The subglyph's second argument (if any).
///
/// p_transform ::
/// The subglyph transformation (if any).
///
/// @return:
/// FreeType error code.  0~means success.
///
/// @note:
/// The values of `*p_arg1', `*p_arg2', and `*p_transform' must be
/// interpreted depending on the flags returned in `*p_flags'.  See the
/// OpenType specification for details.
///
    pub fn FT_Get_SubGlyph_Info(glyph: FT_GlyphSlot, sub_index: FT_UInt,
                                p_index: *mut FT_Int, p_flags: *mut FT_UInt,
                                p_arg1: *mut FT_Int, p_arg2: *mut FT_Int,
                                p_transform: *mut FT_Matrix) -> FT_Error;
}
extern "C" {
    pub fn FT_Get_FSType_Flags(face: FT_Face) -> FT_UShort;
}
extern "C" {
    
    pub fn FT_Face_GetCharVariantIndex(face: FT_Face, charcode: FT_ULong,
                                       variantSelector: FT_ULong) -> FT_UInt;
}
extern "C" {
    
    pub fn FT_Face_GetCharVariantIsDefault(face: FT_Face, charcode: FT_ULong,
                                           variantSelector: FT_ULong)
     -> FT_Int;
}
extern "C" {
    pub fn FT_Face_GetVariantSelectors(face: FT_Face) -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_Face_GetVariantsOfChar(face: FT_Face, charcode: FT_ULong)
     -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_Face_GetCharsOfVariant(face: FT_Face, variantSelector: FT_ULong)
     -> *mut FT_UInt32;
}
extern "C" {
    pub fn FT_MulDiv(a: FT_Long, b: FT_Long, c: FT_Long) -> FT_Long;
}
extern "C" {
    pub fn FT_MulFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
extern "C" {
    
    pub fn FT_DivFix(a: FT_Long, b: FT_Long) -> FT_Long;
}
extern "C" {
    
    pub fn FT_RoundFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {
    
    pub fn FT_CeilFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {
    
    pub fn FT_FloorFix(a: FT_Fixed) -> FT_Fixed;
}
extern "C" {
    
    pub fn FT_Vector_Transform(vec: *mut FT_Vector, matrix: *const FT_Matrix);
}
extern "C" {
    pub fn FT_Library_Version(library: FT_Library, amajor: *mut FT_Int,
                              aminor: *mut FT_Int, apatch: *mut FT_Int);
}
extern "C" {
    
    pub fn FT_Face_CheckTrueTypePatents(face: FT_Face) -> FT_Bool;
}
extern "C" {
    
    pub fn FT_Face_SetUnpatentedHinting(face: FT_Face, value: FT_Bool)
     -> FT_Bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Glyph_Class_ {
    _unused: [u8; 0],
}

pub type FT_Glyph_Class = FT_Glyph_Class_;

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_GlyphRec_ {
    pub library: FT_Library,
    pub clazz: *const FT_Glyph_Class,
    pub format: FT_Glyph_Format,
    pub advance: FT_Vector,
}
#[test]
fn bindgen_test_layout_FT_GlyphRec_() {
    assert_eq!(::std::mem::size_of::<FT_GlyphRec_>() , 40usize , concat ! (
               "Size of: " , stringify ! ( FT_GlyphRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_GlyphRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FT_GlyphRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphRec_ ) ) . library as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphRec_ ) , "::" ,
                stringify ! ( library ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphRec_ ) ) . clazz as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphRec_ ) , "::" ,
                stringify ! ( clazz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphRec_ ) ) . format as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphRec_ ) , "::" ,
                stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_GlyphRec_ ) ) . advance as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_GlyphRec_ ) , "::" ,
                stringify ! ( advance ) ));
}
impl Clone for FT_GlyphRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_Glyph = *mut FT_GlyphRec_;
pub type FT_GlyphRec = FT_GlyphRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_BitmapGlyphRec_ {
    pub root: FT_GlyphRec,
    pub left: FT_Int,
    pub top: FT_Int,
    pub bitmap: FT_Bitmap,
}
#[test]
fn bindgen_test_layout_FT_BitmapGlyphRec_() {
    assert_eq!(::std::mem::size_of::<FT_BitmapGlyphRec_>() , 88usize , concat
               ! ( "Size of: " , stringify ! ( FT_BitmapGlyphRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_BitmapGlyphRec_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FT_BitmapGlyphRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BitmapGlyphRec_ ) ) . root as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BitmapGlyphRec_ ) ,
                "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BitmapGlyphRec_ ) ) . left as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BitmapGlyphRec_ ) ,
                "::" , stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BitmapGlyphRec_ ) ) . top as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BitmapGlyphRec_ ) ,
                "::" , stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_BitmapGlyphRec_ ) ) . bitmap as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_BitmapGlyphRec_ ) ,
                "::" , stringify ! ( bitmap ) ));
}
impl Clone for FT_BitmapGlyphRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_BitmapGlyph = *mut FT_BitmapGlyphRec_;
pub type FT_BitmapGlyphRec = FT_BitmapGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FT_OutlineGlyphRec_ {
    pub root: FT_GlyphRec,
    pub outline: FT_Outline,
}
#[test]
fn bindgen_test_layout_FT_OutlineGlyphRec_() {
    assert_eq!(::std::mem::size_of::<FT_OutlineGlyphRec_>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( FT_OutlineGlyphRec_ ) ));
    assert_eq! (::std::mem::align_of::<FT_OutlineGlyphRec_>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( FT_OutlineGlyphRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_OutlineGlyphRec_ ) ) . root as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_OutlineGlyphRec_ ) ,
                "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FT_OutlineGlyphRec_ ) ) . outline as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( FT_OutlineGlyphRec_ ) ,
                "::" , stringify ! ( outline ) ));
}
impl Clone for FT_OutlineGlyphRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FT_OutlineGlyph = *mut FT_OutlineGlyphRec_;
pub type FT_OutlineGlyphRec = FT_OutlineGlyphRec_;
extern "C" {
    pub fn FT_Get_Glyph(slot: FT_GlyphSlot, aglyph: *mut FT_Glyph)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Glyph_Copy(source: FT_Glyph, target: *mut FT_Glyph) -> FT_Error;
}
extern "C" {
    
    pub fn FT_Glyph_Transform(glyph: FT_Glyph, matrix: *mut FT_Matrix,
                              delta: *mut FT_Vector) -> FT_Error;
}
pub const FT_Glyph_BBox_Mode__FT_GLYPH_BBOX_SUBPIXELS: FT_Glyph_BBox_Mode_ =
    FT_Glyph_BBox_Mode_::FT_GLYPH_BBOX_UNSCALED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FT_Glyph_BBox_Mode_ {
    FT_GLYPH_BBOX_UNSCALED = 0,
    FT_GLYPH_BBOX_GRIDFIT = 1,
    FT_GLYPH_BBOX_TRUNCATE = 2,
    FT_GLYPH_BBOX_PIXELS = 3,
}
pub use self::FT_Glyph_BBox_Mode_ as FT_Glyph_BBox_Mode;
extern "C" {
    pub fn FT_Glyph_Get_CBox(glyph: FT_Glyph, bbox_mode: FT_UInt,
                             acbox: *mut FT_BBox);
}
extern "C" {
    pub fn FT_Glyph_To_Bitmap(the_glyph: *mut FT_Glyph,
                              render_mode: FT_Render_Mode,
                              origin: *mut FT_Vector, destroy: FT_Bool)
     -> FT_Error;
}
extern "C" {
    
    pub fn FT_Done_Glyph(glyph: FT_Glyph);
}
extern "C" {
    
    pub fn FT_Matrix_Multiply(a: *const FT_Matrix, b: *mut FT_Matrix);
}
extern "C" {
    
    pub fn FT_Matrix_Invert(matrix: *mut FT_Matrix) -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Init(abitmap: *mut FT_Bitmap);
}
extern "C" {
    pub fn FT_Bitmap_New(abitmap: *mut FT_Bitmap);
}
extern "C" {
    
    pub fn FT_Bitmap_Copy(library: FT_Library, source: *const FT_Bitmap,
                          target: *mut FT_Bitmap) -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Embolden(library: FT_Library, bitmap: *mut FT_Bitmap,
                              xStrength: FT_Pos, yStrength: FT_Pos)
     -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Convert(library: FT_Library, source: *const FT_Bitmap,
                             target: *mut FT_Bitmap, alignment: FT_Int)
     -> FT_Error;
}
extern "C" {
    pub fn FT_GlyphSlot_Own_Bitmap(slot: FT_GlyphSlot) -> FT_Error;
}
extern "C" {
    pub fn FT_Bitmap_Done(library: FT_Library, bitmap: *mut FT_Bitmap)
     -> FT_Error;
}
/// @type: FTC_FaceID
///
/// @description:
/// An opaque pointer type that is used to identity face objects.  The
/// contents of such objects is application-dependent.
///
/// These pointers are typically used to point to a user-defined
/// structure containing a font file path, and face index.
///
/// @note:
/// Never use NULL as a valid @FTC_FaceID.
///
/// Face IDs are passed by the client to the cache manager that calls,
/// when needed, the @FTC_Face_Requester to translate them into new
/// @FT_Face objects.
///
/// If the content of a given face ID changes at runtime, or if the value
/// becomes invalid (e.g., when uninstalling a font), you should
/// immediately call @FTC_Manager_RemoveFaceID before any other cache
/// function.
///
/// Failure to do so will result in incorrect behaviour or even
/// memory leaks and crashes.
pub type FTC_FaceID = FT_Pointer;
/// @functype:
/// FTC_Face_Requester
///
/// @description:
/// A callback function provided by client applications.  It is used by
/// the cache manager to translate a given @FTC_FaceID into a new valid
/// @FT_Face object, on demand.
///
/// <Input>
/// face_id ::
/// The face ID to resolve.
///
/// library ::
/// A handle to a FreeType library object.
///
/// req_data ::
/// Application-provided request data (see note below).
///
/// <Output>
/// aface ::
/// A new @FT_Face handle.
///
/// <Return>
/// FreeType error code.  0~means success.
///
/// <Note>
/// The third parameter `req_data' is the same as the one passed by the
/// client when @FTC_Manager_New is called.
///
/// The face requester should not perform funny things on the returned
/// face object, like creating a new @FT_Size for it, or setting a
/// transformation through @FT_Set_Transform!
pub type FTC_Face_Requester =
    ::std::option::Option<unsafe extern "C" fn(face_id: FTC_FaceID,
                                               library: FT_Library,
                                               req_data: FT_Pointer,
                                               aface: *mut FT_Face)
                              -> FT_Error>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FTC_ManagerRec_ {
    _unused: [u8; 0],
}
pub type FTC_Manager = *mut FTC_ManagerRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FTC_NodeRec_ {
    _unused: [u8; 0],
}
pub type FTC_Node = *mut FTC_NodeRec_;
extern "C" {
    pub fn FTC_Manager_New(library: FT_Library, max_faces: FT_UInt,
                           max_sizes: FT_UInt, max_bytes: FT_ULong,
                           requester: FTC_Face_Requester,
                           req_data: FT_Pointer, amanager: *mut FTC_Manager)
     -> FT_Error;
}
extern "C" {
    pub fn FTC_Manager_Reset(manager: FTC_Manager);
}
extern "C" {
    
    pub fn FTC_Manager_Done(manager: FTC_Manager);
}
extern "C" {
    pub fn FTC_Manager_LookupFace(manager: FTC_Manager, face_id: FTC_FaceID,
                                  aface: *mut FT_Face) -> FT_Error;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FTC_ScalerRec_ {
    pub face_id: FTC_FaceID,
    pub width: FT_UInt,
    pub height: FT_UInt,
    pub pixel: FT_Int,
    pub x_res: FT_UInt,
    pub y_res: FT_UInt,
}
#[test]
fn bindgen_test_layout_FTC_ScalerRec_() {
    assert_eq!(::std::mem::size_of::<FTC_ScalerRec_>() , 32usize , concat ! (
               "Size of: " , stringify ! ( FTC_ScalerRec_ ) ));
    assert_eq! (::std::mem::align_of::<FTC_ScalerRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FTC_ScalerRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ScalerRec_ ) ) . face_id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ScalerRec_ ) , "::"
                , stringify ! ( face_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ScalerRec_ ) ) . width as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ScalerRec_ ) , "::"
                , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ScalerRec_ ) ) . height as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ScalerRec_ ) , "::"
                , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ScalerRec_ ) ) . pixel as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ScalerRec_ ) , "::"
                , stringify ! ( pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ScalerRec_ ) ) . x_res as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ScalerRec_ ) , "::"
                , stringify ! ( x_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ScalerRec_ ) ) . y_res as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ScalerRec_ ) , "::"
                , stringify ! ( y_res ) ));
}
impl Clone for FTC_ScalerRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FTC_ScalerRec = FTC_ScalerRec_;
pub type FTC_Scaler = *mut FTC_ScalerRec_;
extern "C" {
    pub fn FTC_Manager_LookupSize(manager: FTC_Manager, scaler: FTC_Scaler,
                                  asize: *mut FT_Size) -> FT_Error;
}
extern "C" {
    
    pub fn FTC_Node_Unref(node: FTC_Node, manager: FTC_Manager);
}
extern "C" {
    /// @function:
/// FTC_Manager_RemoveFaceID
///
/// @description:
/// A special function used to indicate to the cache manager that
/// a given @FTC_FaceID is no longer valid, either because its
/// content changed, or because it was deallocated or uninstalled.
///
/// @input:
/// manager ::
/// The cache manager handle.
///
/// face_id ::
/// The @FTC_FaceID to be removed.
///
/// @note:
/// This function flushes all nodes from the cache corresponding to this
/// `face_id', with the exception of nodes with a non-null reference
/// count.
///
/// Such nodes are however modified internally so as to never appear
/// in later lookups with the same `face_id' value, and to be immediately
/// destroyed when released by all their users.
///
    pub fn FTC_Manager_RemoveFaceID(manager: FTC_Manager,
                                    face_id: FTC_FaceID);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FTC_CMapCacheRec_ {
    _unused: [u8; 0],
}
/// @type:
/// FTC_CMapCache
///
/// @description:
/// An opaque handle used to model a charmap cache.  This cache is to
/// hold character codes -> glyph indices mappings.
///
pub type FTC_CMapCache = *mut FTC_CMapCacheRec_;
extern "C" {
    /// @function:
/// FTC_CMapCache_New
///
/// @description:
/// Create a new charmap cache.
///
/// @input:
/// manager ::
/// A handle to the cache manager.
///
/// @output:
/// acache ::
/// A new cache handle.  NULL in case of error.
///
/// @return:
/// FreeType error code.  0~means success.
///
/// @note:
/// Like all other caches, this one will be destroyed with the cache
/// manager.
///
    pub fn FTC_CMapCache_New(manager: FTC_Manager, acache: *mut FTC_CMapCache)
     -> FT_Error;
}
extern "C" {
    /// @function:
/// FTC_CMapCache_Lookup
///
/// @description:
/// Translate a character code into a glyph index, using the charmap
/// cache.
///
/// @input:
/// cache ::
/// A charmap cache handle.
///
/// face_id ::
/// The source face ID.
///
/// cmap_index ::
/// The index of the charmap in the source face.  Any negative value
/// means to use the cache @FT_Face's default charmap.
///
/// char_code ::
/// The character code (in the corresponding charmap).
///
/// @return:
/// Glyph index.  0~means `no glyph'.
///
    pub fn FTC_CMapCache_Lookup(cache: FTC_CMapCache, face_id: FTC_FaceID,
                                cmap_index: FT_Int, char_code: FT_UInt32)
     -> FT_UInt;
}
/// @struct:
/// FTC_ImageTypeRec
///
/// @description:
/// A structure used to model the type of images in a glyph cache.
///
/// @fields:
/// face_id ::
/// The face ID.
///
/// width ::
/// The width in pixels.
///
/// height ::
/// The height in pixels.
///
/// flags ::
/// The load flags, as in @FT_Load_Glyph.
///
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FTC_ImageTypeRec_ {
    pub face_id: FTC_FaceID,
    pub width: FT_UInt,
    pub height: FT_UInt,
    pub flags: FT_Int32,
}
#[test]
fn bindgen_test_layout_FTC_ImageTypeRec_() {
    assert_eq!(::std::mem::size_of::<FTC_ImageTypeRec_>() , 24usize , concat !
               ( "Size of: " , stringify ! ( FTC_ImageTypeRec_ ) ));
    assert_eq! (::std::mem::align_of::<FTC_ImageTypeRec_>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( FTC_ImageTypeRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ImageTypeRec_ ) ) . face_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ImageTypeRec_ ) ,
                "::" , stringify ! ( face_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ImageTypeRec_ ) ) . width as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ImageTypeRec_ ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ImageTypeRec_ ) ) . height as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ImageTypeRec_ ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_ImageTypeRec_ ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_ImageTypeRec_ ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for FTC_ImageTypeRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FTC_ImageTypeRec = FTC_ImageTypeRec_;
/// @type:
/// FTC_ImageType
///
/// @description:
/// A handle to an @FTC_ImageTypeRec structure.
///
pub type FTC_ImageType = *mut FTC_ImageTypeRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FTC_ImageCacheRec_ {
    _unused: [u8; 0],
}

pub type FTC_ImageCache = *mut FTC_ImageCacheRec_;
extern "C" {
    
    pub fn FTC_ImageCache_New(manager: FTC_Manager,
                              acache: *mut FTC_ImageCache) -> FT_Error;
}
extern "C" {
    pub fn FTC_ImageCache_Lookup(cache: FTC_ImageCache, type_: FTC_ImageType,
                                 gindex: FT_UInt, aglyph: *mut FT_Glyph,
                                 anode: *mut FTC_Node) -> FT_Error;
}
extern "C" {
    pub fn FTC_ImageCache_LookupScaler(cache: FTC_ImageCache,
                                       scaler: FTC_Scaler,
                                       load_flags: FT_ULong, gindex: FT_UInt,
                                       aglyph: *mut FT_Glyph,
                                       anode: *mut FTC_Node) -> FT_Error;
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct FTC_SBitRec_ {
    pub width: FT_Byte,
    pub height: FT_Byte,
    pub left: FT_Char,
    pub top: FT_Char,
    pub format: FT_Byte,
    pub max_grays: FT_Byte,
    pub pitch: FT_Short,
    pub xadvance: FT_Char,
    pub yadvance: FT_Char,
    pub buffer: *mut FT_Byte,
}
#[test]
fn bindgen_test_layout_FTC_SBitRec_() {
    assert_eq!(::std::mem::size_of::<FTC_SBitRec_>() , 24usize , concat ! (
               "Size of: " , stringify ! ( FTC_SBitRec_ ) ));
    assert_eq! (::std::mem::align_of::<FTC_SBitRec_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( FTC_SBitRec_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . width as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . height as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . left as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . top as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . format as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . max_grays as * const _
                as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( max_grays ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . pitch as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . xadvance as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( xadvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . yadvance as * const _
                as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( yadvance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const FTC_SBitRec_ ) ) . buffer as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( FTC_SBitRec_ ) , "::" ,
                stringify ! ( buffer ) ));
}
impl Clone for FTC_SBitRec_ {
    fn clone(&self) -> Self { *self }
}
pub type FTC_SBit = *mut FTC_SBitRec_;
pub type FTC_SBitRec = FTC_SBitRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FTC_SBitCacheRec_ {
    _unused: [u8; 0],
}
pub type FTC_SBitCache = *mut FTC_SBitCacheRec_;
extern "C" {
    
    pub fn FTC_SBitCache_New(manager: FTC_Manager, acache: *mut FTC_SBitCache)
     -> FT_Error;
}
extern "C" {
    pub fn FTC_SBitCache_Lookup(cache: FTC_SBitCache, type_: FTC_ImageType,
                                gindex: FT_UInt, sbit: *mut FTC_SBit,
                                anode: *mut FTC_Node) -> FT_Error;
}
extern "C" {
    pub fn FTC_SBitCache_LookupScaler(cache: FTC_SBitCache,
                                      scaler: FTC_Scaler,
                                      load_flags: FT_ULong, gindex: FT_UInt,
                                      sbit: *mut FTC_SBit,
                                      anode: *mut FTC_Node) -> FT_Error;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}